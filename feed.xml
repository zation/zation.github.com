<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zation's Blog</title>
  <subtitle>Coding for fun</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://zation.me/"/>
  <link href="http://zation.me/feed.xml" rel="self"/>
  <updated>2013-01-28T01:28:00Z</updated>
  <author>
    <name>Zation</name>
  </author>
  <entry>
    <title>数独生成浅尝</title>
    <link rel="alternate" href="/2013/01/28/sudoku_arithmetic_research.html"/>
    <id>/2013/01/28/sudoku_arithmetic_research.html</id>
    <published>2013-01-28T01:28:00Z</published>
    <updated>2013-01-28T01:28:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Sudoku" src="/images/sudoku/cover.jpg?1359528371" /&gt;&lt;/p&gt;

&lt;p&gt;数独是一种非常有意思的游戏，也是我很喜欢的一种游戏，当闲来无事的时候，常常会打开手机里的数独游戏来打发时间。当我们在享受数独游戏的时候，有没有想过每一局游戏是如何生成的呢？看似简单，其实很复杂。有不少相关的算法，还有一个困惑了数学家多年的谜题（2011年12月被解开）。下面就让我们一起来看看数独的生成。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Sudoku" src="/images/sudoku/cover.jpg?1359528371" /&gt;&lt;/p&gt;

&lt;p&gt;数独是一种非常有意思的游戏，也是我很喜欢的一种游戏，当闲来无事的时候，常常会打开手机里的数独游戏来打发时间。当我们在享受数独游戏的时候，有没有想过每一局游戏是如何生成的呢？看似简单，其实很复杂。有不少相关的算法，还有一个困惑了数学家多年的谜题（2011年12月被解开）。下面就让我们一起来看看数独的生成。&lt;/p&gt;

&lt;h3&gt;什么是数独&lt;/h3&gt;

&lt;p&gt;可能有些朋友还不知道什么是数独，下面是来自&lt;a href="http://zh.wikipedia.org/wiki/%E6%95%B8%E7%8D%A8"&gt;维基百科&lt;/a&gt;的解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;數獨 Sudoku（数独，sūdoku，すうどく）&lt;/p&gt;

&lt;p&gt;/suːˈdoʊkuː/soo-DOH-koo是一種邏輯性的數字填充遊戲，玩家須以數字填進每一格，而每行、每列和每個宮（即3x3的大格）有齊1至9所有數字。遊戲設計者會提供一部份的數字，使謎題只有一個答案。&lt;/p&gt;

&lt;p&gt;一個已解答的數獨其實是一種多了宮的限制的拉丁方陣，因為同一個數字不可能在同一行、列或宮中出現多於一次。&lt;/p&gt;

&lt;p&gt;这种游戏只需要逻辑思维能力，与数字运算无关。虽然玩法简单，但数字排列方式却千变万化，所以不少教育者认为数独是锻炼脑筋的好方法。因为数独上的数字没有运算价值，仅仅代表相互区分的不同个体，因此可以使用其他的符号比如拉丁字母、罗马字母甚至是不图形状的图案代替。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是一个数独的题目以及解答：&lt;/p&gt;

&lt;p&gt;&lt;img alt="Sudoku Example" src="/images/sudoku/example.png?1359528371" /&gt;
&lt;img alt="Sudoku Solution" src="/images/sudoku/solution.png?1359528371" /&gt;&lt;/p&gt;

&lt;h3&gt;如何生成数独的解答&lt;/h3&gt;

&lt;p&gt;要生成一个数独，直接生成它的迷局比较困难，我们可以先从解答开始。当我们看到数独的时候，就会发现他其实就是一种数学矩阵，当我们在考虑如何生成数独的时候，也可以从矩阵变换的角度来考虑。我们可以从一个完成的数独开始，例如：&lt;/p&gt;

&lt;p&gt;&lt;img alt="Sudoku Origin" src="/images/sudoku/origin.jpg?1359528371" /&gt;&lt;/p&gt;

&lt;p&gt;对于这个9x9的矩阵，我们现在要考虑的就是如何打乱每个数字的位置，而不破坏它的规律——每行、每列、每宫都有1至9的所有数字。符合这个条件的矩阵变化有以下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;交换每组（1-3行为一组，4-6行为一组，7-9行为一组）中的任意两行：&lt;/p&gt;

&lt;p&gt;&lt;img alt="Sudoku Transform 1" src="/images/sudoku/transform1.jpg?1359528371" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同样也可以交换每组中的任意两列。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组之间的行互换：&lt;/p&gt;

&lt;p&gt;&lt;img alt="Sudoku Transform 2" src="/images/sudoku/transform2.jpg?1359528371" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同样也可以组之间的列互换。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;矩阵转置：&lt;/p&gt;

&lt;p&gt;&lt;img alt="Sudoku Transform 3" src="/images/sudoku/transform3.jpg?1359528371" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几乎各种编程语言都会有矩阵计算的库，由于本人比较专注于JavaScript，所以这里推荐一个JavaScript的矩阵计算库：&lt;a href="http://sylvester.jcoglan.com/"&gt;Sylvester&lt;/a&gt;，有了矩阵计算库的支持，再加上前面几种等价变换，我们可以很容易生成出一个数独的结局。&lt;/p&gt;

&lt;h3&gt;如何生成数独的迷局&lt;/h3&gt;

&lt;p&gt;结局生成好了以后，下一步就是要清空其中的某些数字格，从而生成迷局，这是最难也最有讲究的。数独游戏有一个“潜规则”：每个游戏只能有一个解答，如果有两个或者以上的解答，那么游戏的难度将会降低。所以我们在清空数字格的时候也不能随意的清空，我们必须保证它最后只有唯一解。&lt;/p&gt;

&lt;p&gt;很遗憾的是，在我的能力范围之内以及搜索范围内没有找到有哪种算法可以保证数独只有唯一解，也没有某种算法可以验证一个谜题是否一定有多个解（除非有一组三行全为空）。不过一些研究标明，有某种pattern会导致数独一定有多个解，请见&lt;a href="http://www.sudoku.org.uk/SolvingTechniques/UniqueRectangles.asp"&gt;“Deadly Pattern”&lt;/a&gt;。我们可以做的有以下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;保证在去掉数字格的过程中不会同时去掉一组的三行&lt;/li&gt;
&lt;li&gt;使用Solver验证生成的迷局是否有多个解&lt;/li&gt;
&lt;li&gt;当出现“Deadly Pattern”时，撤销上一次去掉数字格的操作，重新去掉一个新的，再次回到上一步做验证&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;数独的数学谜题&lt;/h3&gt;

&lt;p&gt;这里还有一个困扰了数学家数十年的问题：&lt;strong&gt;数独游戏最少需要多少个数字，才能保证最后有唯一解？&lt;/strong&gt;曾经有数学家找到过17个数字并且具有唯一解的数独，但是一直没有找到16个数字的唯一解数独。于是部分数学家相信17个数字就是唯一解数独的最少数字了，也有数学家任然在寻找16个数字的唯一解数独，只是一直都无法证明17这一最少数字，也一直没有找到16个数字的唯一解数独。&lt;/p&gt;

&lt;p&gt;这个谜题终于在2011年12月被Gary McGuire以及他在都柏林大学的朋友们一起破解了，他们利用计算机程序遍历了所有16数字的数独，最终没有发现唯一解数独，从而以穷举的方式证明了&lt;strong&gt;数独游戏最少需要17个数字，才能保证最后有唯一解。&lt;/strong&gt;他们利用对称性去掉了所有等价的数独，任然计算了5,472,730,538次以及一年的时间才得到这个结果。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.forret.com/2006/08/a-sudoku-challenge-generator/"&gt;A Sudoku challenge generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.technologyreview.com/view/426554/mathematicians-solve-minimum-sudoku-problem/"&gt;Mathematicians Solve Minimum Sudoku Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>利用Backbone.js重构项目代码</title>
    <link rel="alternate" href="/2013/01/22/backbone_refator.html"/>
    <id>/2013/01/22/backbone_refator.html</id>
    <published>2013-01-22T14:28:00Z</published>
    <updated>2013-01-22T14:28:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;进入现在这个项目已经一年多了，这是我呆过时间最长的一个项目，见证了项目的前端从简单的一些效果到有了复杂的逻辑，最后需要借助JavaScript的MVC框架来重构前端代码，以避免前端代码爆炸失控。具体来说我们的前端代码在增长过程中遇到了以下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多个页面组件根据同一数据来源做更新显示时，会有不少逻辑上重复的代码，或者过多的回调嵌套；&lt;/li&gt;
&lt;li&gt;由于缺乏一个消息传递机制，导致全局变量很多；&lt;/li&gt;
&lt;li&gt;组件之间耦合太深，单个组件很难被重用；&lt;/li&gt;
&lt;li&gt;数据被写在DOM元素的属性中，当显示需求改变时很难只修改DOM而不破坏功能；&lt;/li&gt;
&lt;li&gt;测试代码中需要准备大量的html fixture，每个测试都是很大的集成测试，难以重构、相当耗时。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当你遇到其中一个或几个问题时，请开始考虑用&lt;a href="http://backbonejs.org/"&gt;Backbone.js&lt;/a&gt;来重构吧，越是问题严重的时候重构的风险越大，花费的时间和精力也越多，最后可能是遗留一大堆垃圾代码而草草了结项目。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;进入现在这个项目已经一年多了，这是我呆过时间最长的一个项目，见证了项目的前端从简单的一些效果到有了复杂的逻辑，最后需要借助JavaScript的MVC框架来重构前端代码，以避免前端代码爆炸失控。具体来说我们的前端代码在增长过程中遇到了以下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多个页面组件根据同一数据来源做更新显示时，会有不少逻辑上重复的代码，或者过多的回调嵌套；&lt;/li&gt;
&lt;li&gt;由于缺乏一个消息传递机制，导致全局变量很多；&lt;/li&gt;
&lt;li&gt;组件之间耦合太深，单个组件很难被重用；&lt;/li&gt;
&lt;li&gt;数据被写在DOM元素的属性中，当显示需求改变时很难只修改DOM而不破坏功能；&lt;/li&gt;
&lt;li&gt;测试代码中需要准备大量的html fixture，每个测试都是很大的集成测试，难以重构、相当耗时。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当你遇到其中一个或几个问题时，请开始考虑用&lt;a href="http://backbonejs.org/"&gt;Backbone.js&lt;/a&gt;来重构吧，越是问题严重的时候重构的风险越大，花费的时间和精力也越多，最后可能是遗留一大堆垃圾代码而草草了结项目。&lt;/p&gt;

&lt;h3&gt;Backbone.js是一种怎样的框架？&lt;/h3&gt;

&lt;p&gt;很多人看到JavaScript MVC框架，就觉得这是一个很重的框架，其实它是非常轻量级的框架。你可以只使用你需要的核心部分，其余的功能可以等到需要的时候再使用，而不必完全按照某种编码风格或方式。我们可以分离开来的几个核心部分有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事件机制：主要用于Model和View或者View之间传递消息。&lt;/li&gt;
&lt;li&gt;Model：主要用于数据处理，或者与后台交互。&lt;/li&gt;
&lt;li&gt;View：使用Backbone.js的View可以比较方便的封装组件，但是也完全可以延用自己的组件代码，绑定Model。&lt;/li&gt;
&lt;li&gt;Collection：提供了很多复杂逻辑操作的方法，对于成组的数据操作很方便，但实际上这些逻辑操作的方法都是来自&lt;a href="http://underscorejs.org/"&gt;Underscore.js&lt;/a&gt;的，它们都可以独立使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他还有Route、History、Sync等部分，基本都是用于大型前端应用了，可以按需使用。下面我们来看看具体如何利用Backbone.js做重构。&lt;/p&gt;

&lt;h3&gt;使用Model封装数据&lt;/h3&gt;

&lt;p&gt;当我们面临一个复杂的Web项目，首先要做的就是尽量将其中的数据逻辑和显示逻辑分开。Backbone.js中使用Model来封装数据逻辑，并且提供了&lt;code&gt;fectch&lt;/code&gt;、&lt;code&gt;save&lt;/code&gt;、&lt;code&gt;sync&lt;/code&gt;一系列与后台交互的辅助方法，不过我们也可以使用自定义的方式来灵活处理后台交互。&lt;/p&gt;

&lt;p&gt;当我们有一些图书的数据需要与后台交互，如果是使用Backbone.js自带的方法的话，会有类似以下代码的写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Book = Backbone.Model.extend({
    urlRoot: &amp;#39;books&amp;#39;
});

var book = new Book({
    id: 1,
    name: &amp;#39;a book&amp;#39;
});

book.save();
book.fetch();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能对这段代码做了什么大家不是很了解，下面是自定义的写法，就可以看的很清楚：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Book = Backbone.Model.extend({
    save: function() {
        $.ajax({
            url: &amp;#39;books&amp;#39;,
            method: &amp;#39;POST&amp;#39;,
            data: {
                id: this.id,
                name: this.name
            }
        });
    },

    fetch: function() {
        $.ajax({
            url: &amp;#39;books/&amp;#39; + this.id,
            method: &amp;#39;get&amp;#39;,
            success: function(data) {
                this.id = data.id;
                this.name = data.name;
            }
        });
    }
});

var book = new Book({
    id: 1,
    name: &amp;#39;a book&amp;#39;
});

book.save();
book.fetch();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两段代码的执行结果都是一样的，不同的是在第二段中我复写了Backbone.js的两个默认方法，让大家可以看到实际执行的操作是什么样的。&lt;/p&gt;

&lt;p&gt;第一段代码的写法是很简洁，但是他需要后台提供完善、标准的RESTful接口，而这在重构的初期几乎是不可能的。所以我们可以先像第二段代码那样重写Backbone.js的默认方法，使之符合我们的前后端交互规则，来抽离出数据逻辑。并且在我们一步一步抽离出数据逻辑的同时，也可以补齐这部分的单元测试，推荐使用&lt;a href="https://github.com/pivotal/jasmine"&gt;jasmine测试框架&lt;/a&gt;来写JavaScript单元测试，以及使用&lt;a href="https://github.com/pivotal/jasmine-ajax"&gt;jasmine-ajax&lt;/a&gt;来mock ajax请求。&lt;/p&gt;

&lt;h3&gt;利用事件机制解耦代码&lt;/h3&gt;

&lt;p&gt;前端代码的复杂性在于依赖，JavaScript依赖于DOM，DOM之间又有很强的层级结构，而DOM之间的消息传递机制就只有由用户触发的交互事件，如：click、change、hover等等，不能由DOM主动触发并且传递给其他DOM元素。于是我们的组件内部就非常多的持有了其他组件，造成了依赖复杂，难以解耦和复用。这个问题的处理方法是自己写一套事件机制，或者使用框架的事件机制，而Backbone.js就提供了一套很好的事件机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基于Model的事件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多时候我们需要根据数据的变化来更新组件的显示，Backbone.js的Model就提供了这种事件机制。假如我们现在的页面中有一个View是用于显示书本的信息，那么当书本数据变更时可以这样更新View的显示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var BookView = Backbone.View.extend({
    initialize: function() {
        this.model.on(&amp;#39;change&amp;#39;, this.render, this);
    },

    render: function() {
        this.$(&amp;#39;.name&amp;#39;).text(this.model.get(&amp;#39;name&amp;#39;));
        this.$(&amp;#39;.author&amp;#39;).text(this.model.get(&amp;#39;author&amp;#39;));
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当&lt;code&gt;BookView&lt;/code&gt;所绑定的Model变更时，就会自动调用&lt;code&gt;render&lt;/code&gt;来更新显示，其中消息传递和触发的机制已经由Backbone.js实现了，我们只需要使用就可以了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;View之间的消息传递&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;还有很多时候我们需要在View之间传递消息，这些消息是与数据无关的，典型的例子就是弹出通知框。假如我们现在需要在书本信息更新完毕以后，弹出一个通知框告诉用户书本信息已经更新成功了，以前的做法是将通知框的实例作为一个全局的变量，让每个需要用到它的地方都可以直接调用它的某个弹出方法。但是我们现在可以用&lt;code&gt;Backbone.Events&lt;/code&gt;来做解耦：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var CustomEvent = {showNotification: &amp;#39;showNotification&amp;#39;};
_.extend(CustomEvent, Backbone.Events);

var NotificationView = Backbone.View.extend({
    initialize: function() {
        CustomEvent.on(CustomEvent.showNotification, this.showNotification);
    },

    showNotification: function() {
        this.$el.show();
    }
});

var BookView = Backbone.View.extend({
    initialize: function() {
        this.model.on(&amp;#39;change&amp;#39;, this.render, this);
    },

    render: function() {
        this.$(&amp;#39;.name&amp;#39;).text(this.model.get(&amp;#39;name&amp;#39;));
        this.$(&amp;#39;.author&amp;#39;).text(this.model.get(&amp;#39;author&amp;#39;));
        CustomEvent.trigger(CustomEvent.showNotification);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以将两个View之间的耦合解开了。当然，这里从实现上来讲也可以使用Model来传递消息，但是这样并不符合Model的语义，而且也没有用到Model真正的功能，太重了一些，所以推荐还是用自己的事件对象，通过继承&lt;code&gt;Backbone.Events&lt;/code&gt;来实现。&lt;/p&gt;

&lt;h3&gt;一些Tips&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;关于测试的优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当我们利用Backbone.js的View和Model将我们的前端代码组件化，并且分离了显示逻辑和数据逻辑之后，我们的测试代码也变得好些多了，可以更加靠近单元测试。我们可以将以前的集成测试分拆为小的单元测试，并且在准备fixture的时候也尽量小，同时注意不要将fixture真的append到DOM中，那样会减慢测试的运行速度。&lt;/p&gt;

&lt;p&gt;但是这里也有例外，如果你是使用&lt;a href="https://github.com/velesin/jasmine-jquery"&gt;jasmine-jquery&lt;/a&gt;来测试DOM元素，那么针对元素的显示/隐藏逻辑的测试，必须要将fixture真的append到DOM才能得到正确的结果。这是由于jasmine-jquery的&lt;code&gt;toBeVisible&lt;/code&gt;使用了jQuery的&lt;code&gt;is(&amp;#39;:visible&amp;#39;)&lt;/code&gt;来验证元素的显示/隐藏，它要求元素必须存在于DOM中才可能是隐藏的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于View内部元素的获取&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们常常需要在View中选取它内部的元素，这个时候如果直接使用&lt;code&gt;$(selector)&lt;/code&gt;可能或选取到View外部拥有同样selector的元素。Backbone.js已经提供了一个很好的解决方案，就是&lt;code&gt;this.$(selector)&lt;/code&gt;，它只会选取该View内部的元素，从而将外部DOM元素隔离的很干净。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于View的DOM事件绑定&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;View的DOM事件绑定是以如下方式进行的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var BookView = Backbone.View.extend({
    events: {
        &amp;#39;click .delete&amp;#39;, &amp;#39;deleteBook&amp;#39;
    },

    deleteBook: function() {
        ...
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能大家会觉得这里的事件绑定等同于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&amp;#39;.delete&amp;#39;).on(&amp;#39;click&amp;#39;, function() {…})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是实际上Backbone.js会把每个View的事件都delegate到它的根元素上，假如我们是这样创建View的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var bookView = BookView({el: &amp;#39;.book&amp;#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么它的事件绑定就等同于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&amp;#39;.book&amp;#39;).on(&amp;#39;click&amp;#39;, &amp;#39;.delete&amp;#39;, function() {…})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，即使&lt;code&gt;.delete&lt;/code&gt;是动态创建的，事件能绑定上。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Sass &amp; Compass Best Practices 3——图片处理</title>
    <link rel="alternate" href="/2013/01/13/sass_compass_best_practices_3.html"/>
    <id>/2013/01/13/sass_compass_best_practices_3.html</id>
    <published>2013-01-13T13:15:00Z</published>
    <updated>2013-01-13T13:15:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;a href="/2013/01/09/sass_compass_best_practices_2.html"&gt;前一篇文章&lt;/a&gt;中我们介绍了如何利用Sass来简化我们的代码，使我们的代码可复用且易维护。本文讲介绍如何使用Compass来管理我们用于样式的图片。&lt;/p&gt;

&lt;p&gt;Compass的图片处理主要有以下功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自动将一系列单个图片拼接生成一个Sprites；&lt;/li&gt;
&lt;li&gt;根据图片名，自动计算background-position并生成CSS代码；&lt;/li&gt;
&lt;li&gt;自动给图片加上防缓存机制。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们就来看看如何具体实现这些功能。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;a href="/2013/01/09/sass_compass_best_practices_2.html"&gt;前一篇文章&lt;/a&gt;中我们介绍了如何利用Sass来简化我们的代码，使我们的代码可复用且易维护。本文讲介绍如何使用Compass来管理我们用于样式的图片。&lt;/p&gt;

&lt;p&gt;Compass的图片处理主要有以下功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自动将一系列单个图片拼接生成一个Sprites；&lt;/li&gt;
&lt;li&gt;根据图片名，自动计算background-position并生成CSS代码；&lt;/li&gt;
&lt;li&gt;自动给图片加上防缓存机制。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们就来看看如何具体实现这些功能。&lt;/p&gt;

&lt;h3&gt;Sprites&lt;/h3&gt;

&lt;p&gt;Sprites本身在Web开发中就是一个最佳实践，但是他也会带来一些问题，那就是当设计人员将sprites中的一个图标改了哪怕一个像素，只要影响到了其他的图标，开发人员就会吐血的修改所有被影响到的样式代码。而Compass可以使我们的设计人员不用再自己手动拼接图标，前端开发也不用一个像素一个像素的手动寻找图标的位置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们先来看看如何利用Compass来生成Sprites。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先我们准备一些图标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;img title="blogger" alt="blogger" src="/images/../stylesheets/images/icons-showcase/blogger.png?1359343254" /&gt; images/icons/blogger.png&lt;/li&gt;
&lt;li&gt;&lt;img title="flickr" alt="flickr" src="/images/../stylesheets/images/icons-showcase/flickr.png?1359343254" /&gt; images/icons/flickr.png&lt;/li&gt;
&lt;li&gt;&lt;img title="linkedin" alt="linkedin" src="/images/../stylesheets/images/icons-showcase/linkedin.png?1359343254" /&gt; images/icons/linkedin.png&lt;/li&gt;
&lt;li&gt;&lt;img title="rss" alt="rss" src="/images/../stylesheets/images/icons-showcase/rss.png?1359343254" /&gt; images/icons/rss.png&lt;/li&gt;
&lt;li&gt;&lt;img title="twitter" alt="twitter" src="/images/../stylesheets/images/icons-showcase/twitter.png?1359343254" /&gt; images/icons/twitter.png&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将他们放在images/icons中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stylesheets/
    images/
        icons/
            blogger.png
            flickr.png
            ⋯⋯
    _icons.scss
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;_icons.scss&lt;/code&gt;中只需要很简单的设置，我们就可以使用Compass提供的Sprites功能了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@import &amp;quot;images/icons/*.png&amp;quot;;

a[title=&amp;quot;sprites-example-blogger&amp;quot;] {
    @include icons-sprite(blogger);
}

a[title=&amp;quot;sprites-example-flickr&amp;quot;] {
    @include icons-sprite(flickr);
}

⋯⋯
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这里Compass使用了一种&amp;quot;Magic Import&amp;quot;，就是说我们使用时include的方法名，是根据我们的文件夹名字（import的路径中最后一个文件夹）自动生成的。例如，当我们把图片放在social文件夹时，我们的代码就应该写成这样（感谢NB的Ruby元编程）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@import &amp;quot;images/social/*.png&amp;quot;;

a[title=&amp;quot;sprites-example-blogger&amp;quot;] {
    @include social-sprite(blogger);
}

a[title=&amp;quot;sprites-example-flickr&amp;quot;] {
    @include social-sprite(flickr);
}

⋯⋯
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我们来看看使用Compass Sprites做成的图标链接：&lt;/p&gt;

&lt;p&gt;&lt;a title="sprites-example-blogger" href="http://www.zation.com"&gt;blogger&lt;/a&gt;
&lt;a title="sprites-example-flickr" href="http://www.flickr.com"&gt;flickr&lt;/a&gt;
&lt;a title="sprites-example-linkedin" href="http://www.linkedin.com"&gt;linkedin&lt;/a&gt;
&lt;a title="sprites-example-rss" href="http://www.google.com/reader/"&gt;rss&lt;/a&gt;
&lt;a title="sprites-example-twitter" href="/feed.xml"&gt;twitter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;关于Sprites，Compass还提供了很多自定义功能，具体可以参考&lt;a href="http://compass-style.org/help/tutorials/spriting/"&gt;Sprites的教程&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;防止缓存&lt;/h3&gt;

&lt;p&gt;缓存可以使我们的用户更加快速的访问我们的网站，但是同样也产生了问题：当我们修改了背景图片但是没有修改图片名时，缓存服务器会认为该图片并没有改变，而直接返回之前缓存的，导致样式在用户端出现问题。现在只要我们使用了Compass的images提供的mixin，就可以解决这个问题。&lt;/p&gt;

&lt;p&gt;假如我们现在有一个图片foo.png放在images文件夹中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stylesheets/
    images/
        foo.png
    backgrond.scss
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们在&lt;code&gt;background.scss&lt;/code&gt;中使用Compass来设置背景图片：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.comapss {
    @include background(image-url(&amp;quot;foo.png&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么所生成的CSS将会是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.compass {
    background: url(/images/foo.png?1320727111);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要使用相对路径，需要在&lt;code&gt;config.rb&lt;/code&gt;中设置&lt;code&gt;relative_assets = true&lt;/code&gt;，这里到底是使用绝对路径还是使用相对路径，可以根据项目中是否有context path来决定，如果有的话建议使用相对路径。&lt;/p&gt;

&lt;p&gt;默认生成的cache buster是一串数字，根据每次Compass的compile生成。很多项目中已经有了完善的cache buster机制了，这里我们可以在&lt;code&gt;config.rb&lt;/code&gt;中重写&lt;code&gt;asset_cache_buster&lt;/code&gt;这个block来集成自己的项目中。在这个block中返回一个hash（&lt;code&gt;{:path =&amp;gt; &amp;quot;path&amp;quot;, :query =&amp;gt; &amp;quot;query&amp;quot;&lt;/code&gt;）可以设置cache buster为指定的路径或query string；如果返回一个string则自动使用query string。下面是一段来自&lt;a href="http://compass-style.org/help/tutorials/configuration-reference/"&gt;Compass Configuration Reference&lt;/a&gt;的示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asset_cache_buster do |path, real_path|
    if File.exists?(real_path)
        pathname = Pathname.new(path)
        modified_time = File.mtime(real_path).strftime(&amp;quot;%s&amp;quot;)
        new_path = &amp;quot;%s/%s-%s%s&amp;quot; % [pathname.dirname, pathname.basename(pathname.extname), modified_time, pathname.extname]

        {:path =&amp;gt; new_path, :query =&amp;gt; nil}
    end
end
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>Sass &amp; Compass Best Practices 2——简化代码</title>
    <link rel="alternate" href="/2013/01/09/sass_compass_best_practices_2.html"/>
    <id>/2013/01/09/sass_compass_best_practices_2.html</id>
    <published>2013-01-09T07:39:00Z</published>
    <updated>2013-01-09T07:39:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;a href="/2013/01/07/sass_compass_best_practices_1.html"&gt;前一篇文章&lt;/a&gt;中我们介绍了如何利用Sass来组织我们的代码结构，本文中将会介绍如何利用Compass来简化我们的CSS代码，并且提高CSS代码的复用性。&lt;/p&gt;

&lt;p&gt;在我们的CSS开发中，你是否遇到过以下的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为了浏览器的兼容性，同样的效果要写很多行，维护起来很麻烦；&lt;/li&gt;
&lt;li&gt;CSS Selector需要有层级关系，但重复的写同样的父元素使代码看起来很冗余；&lt;/li&gt;
&lt;li&gt;不同的组件拥有同样的样式，但由于有一些细微的差别，导致很难复用，而一旦复用，由于CSS的特性，又不易阅读和维护。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个时候就应该用到Sass的nest和&lt;code&gt;@extend&lt;/code&gt;以及Compass的一些内建mixin了。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;a href="/2013/01/07/sass_compass_best_practices_1.html"&gt;前一篇文章&lt;/a&gt;中我们介绍了如何利用Sass来组织我们的代码结构，本文中将会介绍如何利用Compass来简化我们的CSS代码，并且提高CSS代码的复用性。&lt;/p&gt;

&lt;p&gt;在我们的CSS开发中，你是否遇到过以下的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为了浏览器的兼容性，同样的效果要写很多行，维护起来很麻烦；&lt;/li&gt;
&lt;li&gt;CSS Selector需要有层级关系，但重复的写同样的父元素使代码看起来很冗余；&lt;/li&gt;
&lt;li&gt;不同的组件拥有同样的样式，但由于有一些细微的差别，导致很难复用，而一旦复用，由于CSS的特性，又不易阅读和维护。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个时候就应该用到Sass的nest和&lt;code&gt;@extend&lt;/code&gt;以及Compass的一些内建mixin了。&lt;/p&gt;

&lt;h3&gt;简化兼容性代码&lt;/h3&gt;

&lt;p&gt;当我们在用CSS实现渐变效果时，为了浏览器的兼容性，我们常常会用以下写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* FF3.6+ */
background: -moz-linear-gradient(top, #1e5799 0%, #2989d8 50%, #207cca 51%, #7db9e8 100%);
/* Chrome,Safari4+ */ 
background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#1e5799), color-stop(50%,#2989d8), color-stop(51%,#207cca), color-stop(100%,#7db9e8)); 
/* Chrome10+,Safari5.1+ */
background: -webkit-linear-gradient(top, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%); 
/* Opera 11.10+ */
background: -o-linear-gradient(top, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%); 
/* IE10+ */
background: -ms-linear-gradient(top, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%); 
/* W3C */
background: linear-gradient(to bottom, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%); 
/* IE6-9 */
filter: progid:DXImageTransform.Microsoft.gradient( startColorstr=&amp;#39;#1e5799&amp;#39;, endColorstr=&amp;#39;#7db9e8&amp;#39;,GradientType=0 ); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个简单的渐变，就为了兼容性，变成了超过10行的CSS代码，并且让我们维护起来非常麻烦，一旦有任何修改，我们都必须改7个地方⋯⋯好在Compass为我们提供了解决方案，我们只需要一行代码就可以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@include background-image(linear-gradient(top, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%)); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的功能可以用在box-shadow：&lt;code&gt;@include box-shadow(red 2px 2px 10px);&lt;/code&gt;、inline-block：&lt;code&gt;@include inline-block&lt;/code&gt;、border-radius：&lt;code&gt;@include border-radius(25px);&lt;/code&gt;⋯⋯等等&lt;/p&gt;

&lt;h3&gt;适当的使用nest&lt;/h3&gt;

&lt;p&gt;在CSS中我们常常需要限制样式的作用范围，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.container {
    ⋯⋯
}
.container .article {
    ⋯⋯
}
.container .article .content {
    ⋯⋯
}
.container .article .paragraph {
    ⋯⋯
}
.container .article .link {
    ⋯⋯
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样书写在CSS中没有问题，但是重复的书写&lt;code&gt;.container&lt;/code&gt;和&lt;code&gt;.article&lt;/code&gt;总会让人感到厌倦，并且使同一部分的样式很容易散落在各处，不容易管理。这时候我们就可以使用nest了，它可以帮助我们：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将同一部分的样式归总到一起，方便阅读和维护&lt;/li&gt;
&lt;li&gt;消除重复的selector，特别是父元素的selector&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们来看看使用nest以后的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.container {
    ⋯⋯
    .article {
        ⋯⋯
        .content {
            ⋯⋯
        }
        .paragraph {
            ⋯⋯
        }
        .link {
            ⋯⋯
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是切忌不要过分的使用nest，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.container {
    ⋯⋯
    .article {
        ⋯⋯
        .content {
            ⋯⋯
            .paragraph {
                ⋯⋯
                .link {
                    ⋯⋯
                }
            }
        }       
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它会使最后生成出这样的CSS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.container {
    ⋯⋯
}
.container .article {
    ⋯⋯
}
.container .article .content {
    ⋯⋯
}
.container .article .content .paragraph {
    ⋯⋯
}
.container .article .content .paragraph .link {
    ⋯⋯
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到最后生成的CSS甚至出现了5层selector，一般CSS中出现3层selector已经是比较多了，因为太多的selector会使CSS文件变得冗余，可读性也会变差，而且很难被复用。当你真的需要这么多selector才能完成需求的话，那么你应该反思你的HTML结构是否出现了问题？&lt;/p&gt;

&lt;h3&gt;谨慎的使用@extend&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@extend&lt;/code&gt;可以使我们很方便的复用其他元素的样式，假如我们现在有如下的CSS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h1, h2 {
    font-family: Arial;
    font-size: 38px;
    color: #222;
}
h2 {
    font-size: 24px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用&lt;code&gt;@extend&lt;/code&gt;使代码看起来依赖关系更清晰，并且稍微简单一些（但它实际生成的CSS代码与前相同）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h1 {
    font-family: Arial;
    font-size: 38px;
    color: #222;
}
h2 {
    @extend h1;
    font-size: 24px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它有些类似于&lt;code&gt;@mixin&lt;/code&gt;，不同在于它自身也是CSS，会被页面直接用到。它的目的在于消除重复，并且使依赖关系更加清晰。但是在使用的时候一定要谨慎，因为一个&lt;code&gt;@extend&lt;/code&gt;可以很方便的复用代码，人们往往直接这么一用，也不管是否被复用的所有样式都是需要的，也不管最终生成的CSS是否有冗余。所以我们在使用它的时候请先想想一下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;是否所有的CSS属性都是我所需要的，否则的话复制粘贴其中一部分也不会花太多功夫，不要为了消除重复反而造成冗余&lt;/li&gt;
&lt;li&gt;我所继承的样式中是否还继承了其他样式，不要有多重继承的情况，这样会导致代码理解变得困难&lt;/li&gt;
&lt;li&gt;最终生成的CSS代码是否有selector过长的情况，不要写到最后写成了一个reset⋯⋯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;鉴于&lt;code&gt;@extend&lt;/code&gt;有这样那样的问题，虽然它还是有一定的作用，但是建议用之前一定要谨慎。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Sass &amp; Compass Best Practices 1——组织结构</title>
    <link rel="alternate" href="/2013/01/07/sass_compass_best_practices_1.html"/>
    <id>/2013/01/07/sass_compass_best_practices_1.html</id>
    <published>2013-01-07T08:22:00Z</published>
    <updated>2013-01-07T08:22:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;在CSS开发中你有没有遇到以下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个CSS文件几百上千行，要修改一个样式要找半天；&lt;/li&gt;
&lt;li&gt;为了不同浏览器的兼容性，同样的样式要写好几行代码；&lt;/li&gt;
&lt;li&gt;为了防止背景图片被缓存，每次更改背景图片都要修改图片名称和代码；&lt;/li&gt;
&lt;li&gt;当sprites修改以后，在代码中需要调试半天background-position才能适应新的sprites；&lt;/li&gt;
&lt;li&gt;⋯⋯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当你遇到其中一个或多个问题的时候，说明在CSS代码的管理和维护上出了问题。而这个时候，传统的CSS开发方式已经无法满足这些需求了，我们需要新的开发框架和工具，也就是：&lt;a href="http://sass-lang.com/"&gt;Sass&lt;/a&gt;、&lt;a href="http://compass-style.org/"&gt;Compass&lt;/a&gt;！&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;在CSS开发中你有没有遇到以下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个CSS文件几百上千行，要修改一个样式要找半天；&lt;/li&gt;
&lt;li&gt;为了不同浏览器的兼容性，同样的样式要写好几行代码；&lt;/li&gt;
&lt;li&gt;为了防止背景图片被缓存，每次更改背景图片都要修改图片名称和代码；&lt;/li&gt;
&lt;li&gt;当sprites修改以后，在代码中需要调试半天background-position才能适应新的sprites；&lt;/li&gt;
&lt;li&gt;⋯⋯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当你遇到其中一个或多个问题的时候，说明在CSS代码的管理和维护上出了问题。而这个时候，传统的CSS开发方式已经无法满足这些需求了，我们需要新的开发框架和工具，也就是：&lt;a href="http://sass-lang.com/"&gt;Sass&lt;/a&gt;、&lt;a href="http://compass-style.org/"&gt;Compass&lt;/a&gt;！&lt;/p&gt;

&lt;p&gt;关于Sass和Compass的基本用法，阮一峰有两片写的很好的简介：&lt;a href="http://www.ruanyifeng.com/blog/2012/06/sass.html"&gt;SASS用法指南&lt;/a&gt;、&lt;a href="http://www.ruanyifeng.com/blog/2012/11/compass.html"&gt;Compass用法指南&lt;/a&gt;。这里就不再赘述了，下面我想介绍一系列我们在使用Sass和Compass方面的最佳实践，本文为第一篇：如何模块化CSS代码，使我们的样式也有一个良好的组织结构。&lt;/p&gt;

&lt;h3&gt;CSS代码组织的问题&lt;/h3&gt;

&lt;p&gt;我们在写程序的时候，总是希望可以清楚的了解模块之间的依赖，这样可以方便程序人员理解代码，也方便监控我们的依赖不要过多。假设我们页面的CSS代码已经根据组件和功能划分为不同的模块和CSS文件，其中还有一些第三方的CSS库（reset）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;style/
    reset.css
    layout.css
    menu.css
    document.css
    form/
        form.css
        button.css
        input.css
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相对应的页面&lt;code&gt;header&lt;/code&gt;就会有如下的引用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;header&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;style/reset.css&amp;quot;/&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;style/layout.css&amp;quot;/&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;style/menu.css&amp;quot;/&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;style/document.css&amp;quot;/&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;style/form/form.css&amp;quot;/&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;style/form/button.css&amp;quot;/&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;style/form/input.css&amp;quot;/&amp;gt;
&amp;lt;/header&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们所有的依赖都在HTML中，不利于我们快速的看到样式之间的依赖，也会产生很多额外的HTTP请求，降低页面性能。我们也可以使用&lt;code&gt;@import&lt;/code&gt;在CSS文件内部管理引用，但这同样会产生额外的HTTP请求。&lt;/p&gt;

&lt;h3&gt;利用&lt;code&gt;@import&lt;/code&gt;管理代码&lt;/h3&gt;

&lt;p&gt;当我们希望在CSS代码中就管理所有依赖，并且不会产生额外的request时，就应该用到Sass了。
下面我们看看如果使用了Sass应该是什么样子的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;style/
    screen.scss
    _reset.scss
    _layout.scss
    _menu.scss
    _document.scss
    form/
        _form.scss
        _button.scss
        _input.scss
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;_form.scss&lt;/code&gt;中，我们将管理所有的表单及表单控件的样式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@import &amp;quot;button&amp;quot;;
@import &amp;quot;input&amp;quot;;

form {
    ⋯⋯
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;screen.scss&lt;/code&gt;中，我们将管理所有页面样式的依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@import &amp;quot;reset&amp;quot;;
@import &amp;quot;layout&amp;quot;;
@import &amp;quot;menu&amp;quot;;
@import &amp;quot;document&amp;quot;;
@import &amp;quot;form&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中文件名前面的下划线是告诉Sass该文件只是一个模块，不用单独生成css文件，所以最后生成的css文件只有一个：&lt;code&gt;screen.css&lt;/code&gt;，于是我们只需要一个request就可以引入所有的css文件，写起来也非常方便：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;header&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;style/screen.css&amp;quot;/&amp;gt;
&amp;lt;/header&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能有人会担心这样调试起来会不会很麻烦？但其实如果我们使用Chrome的inspection，我们根本不必接触源代码就可以很好的调试了。&lt;/p&gt;

&lt;p&gt;同时，Compass已经提供了丰富的CSS库，其中包括了rese，所以我们可以直接删除&lt;code&gt;_reset.scss&lt;/code&gt;，只在&lt;code&gt;screen.scss&lt;/code&gt;中引入就可以了。&lt;/p&gt;

&lt;h3&gt;最佳实践和注意&lt;/h3&gt;

&lt;p&gt;下面我们来总结一下在使用Sass帮助我们组织代码结构的时候应该注意的地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将CSS代码按照功能和组件划分为不同的模块，每个模块为一个文件，模块的文件名都以下划线开头，避免Sass生成额外的CSS文件&lt;/li&gt;
&lt;li&gt;当一个模块的代码过多的时候，将之拆分为不同的子模块，并且在一个主模块中管理所有依赖，如：&lt;code&gt;_form.scss&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不要有太多的层级，那样会影响代码的可读性，通常三层已经是极限了&lt;/li&gt;
&lt;li&gt;讲所有第三方引用的库都放在一个文件管理，例如：&lt;code&gt;screen.scss&lt;/code&gt;，即使只有一个模块用到了它。因为重复的引用会在最后生成额外的CSS代码，而在众多的子模块中查找是否已经引入了某个库会非常麻烦，也不便于管理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样既模块化了CSS代码，相互之间的依赖又非常清晰，而且还没有增加额外的request，不失为一个最佳实践。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>不在这里重生，就在这里死去——我在ThoughtWorks的2012</title>
    <link rel="alternate" href="/2012/12/31/summary_of_2012.html"/>
    <id>/2012/12/31/summary_of_2012.html</id>
    <published>2012-12-31T11:32:00Z</published>
    <updated>2012-12-31T11:32:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img title="2012" alt="2012" src="/images/2012.png?1358133542" /&gt;&lt;/p&gt;

&lt;p&gt;在2012的尾巴上回头看去，这几乎就是工作的一年。整整一年我都在西安出差，除了偶尔回成都见见朋友和亲人，就是在公寓与公司之间工作、学习。但这样的一年里，我却有了很多新的尝试和改变：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我在西安电子科技大学给大学生做了演讲&lt;/li&gt;
&lt;li&gt;我在公司做了两次系统的CSS Session&lt;/li&gt;
&lt;li&gt;翻译了《HTML5 Mobile Development Cookbook》&lt;/li&gt;
&lt;li&gt;在Openparty上show了一把现场写jasmine测试&lt;/li&gt;
&lt;li&gt;学习了别人听都没听过的乐器——陶笛&lt;/li&gt;
&lt;li&gt;通宵爬上了华山，却在穿越莫不知名的山峰时以为自己就要死在上面&lt;/li&gt;
&lt;li&gt;我开始阅读经济、创业方面的书籍&lt;/li&gt;
&lt;li&gt;⋯⋯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是更多的，使我思维和观念的转变。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;img title="2012" alt="2012" src="/images/2012.png?1358133542" /&gt;&lt;/p&gt;

&lt;p&gt;在2012的尾巴上回头看去，这几乎就是工作的一年。整整一年我都在西安出差，除了偶尔回成都见见朋友和亲人，就是在公寓与公司之间工作、学习。但这样的一年里，我却有了很多新的尝试和改变：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我在西安电子科技大学给大学生做了演讲&lt;/li&gt;
&lt;li&gt;我在公司做了两次系统的CSS Session&lt;/li&gt;
&lt;li&gt;翻译了《HTML5 Mobile Development Cookbook》&lt;/li&gt;
&lt;li&gt;在Openparty上show了一把现场写jasmine测试&lt;/li&gt;
&lt;li&gt;学习了别人听都没听过的乐器——陶笛&lt;/li&gt;
&lt;li&gt;通宵爬上了华山，却在穿越莫不知名的山峰时以为自己就要死在上面&lt;/li&gt;
&lt;li&gt;我开始阅读经济、创业方面的书籍&lt;/li&gt;
&lt;li&gt;⋯⋯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是更多的，使我思维和观念的转变。&lt;/p&gt;

&lt;h3&gt;学习的最好检验方式，就是把你学到的讲出来。&lt;/h3&gt;

&lt;p&gt;记得刚进入公司的时候，就被大大叫到了小黑屋，布置了每周一个前端开发Session的任务。其实那个时候我对于前端开发并没有特别系统的认识，但还是答应下来。接着就是各种查资料和准备，但除了第一次讲得还行，其他的无论是Session还是Code Jam都不是很理想。最后发现真正收获最多的人是我自己，我终于把以前零散的知识系统的组织起来，而驱使我不断思考不断总结的，就是因为我要把它们讲出来。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在准备的过程中，我会把自己假象为听众，去思考他们会有什么样的问题，这时才发现其实还有很多东西我了解的不是很清楚，于是我不断深钻，研究了所有可能的问题和知识点，再不是以前的浅尝辄止，够用就行。&lt;/li&gt;
&lt;li&gt;在讲解的过程中，我的目的是让别人可以学习和理解我的知识。但如果只是零散的知识，那是不便于别人的理解的，这就需要我自己首先把所有的知识组织起来，总结为一个系统化的“理论”，这种“理论”不需要太深奥，只需要各个知识点都相互关联，又有逐渐深入的示例，别人就很容易理解了。&lt;/li&gt;
&lt;li&gt;在讲解完成以后，别人会给我各种反馈，这些反馈不光是针对技术的，还有针对演讲技巧。它们可以启发我的思考，让我可以持续的对各个方面进行改进。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最终能称得上比较成功的，是两次关于CSS的系列培训，新的一年里我会将它们带到成都办公室，进行新的一轮培训。每一次的培训都是我对自己知识体系的一次完善；都是我对培训方式的一次尝试；也是我对自己表达力、影响力的一次锻炼。&lt;/p&gt;

&lt;h3&gt;用别人的思想，启发自己的思维&lt;/h3&gt;

&lt;p&gt;曾经只读小说和技术书籍的我，今年终于开始涉猎创业和设计方面的书籍：《精益创业》、《简约至上》、《瞬间之美》、《认知与设计》。我才发现对于启发思维，书籍是非常好的工具。其中《精益创业》对我的启发最大，读完以后我才认识到原来我们传统的产品开发模式中有如此多的浪费，其最大的浪费之处不在于效率太低，而在于我们高效率的工作在错误的方向之上，却不自知也不改变。&lt;/p&gt;

&lt;p&gt;新的一年里我准备了更多创业和经济方面的书籍：《四步创业法》、《商业模式新生代》、《黑天鹅》等等，希望我可以对于自己所作的事情有更好的价值评估，对于未来的价值走向也能有一些感觉。&lt;/p&gt;

&lt;h3&gt;“Coding for fun, not coding for 饭”&lt;/h3&gt;

&lt;p&gt;进入ThoughtWorks，注定了我要开始对于技术的狂热追求，在这一年里我参与/创建了27个github repositories，学会了把Web应用发布到各种云平台上，例如Heroku、Cloud Foundry。&lt;/p&gt;

&lt;p&gt;在这里，我终于知道了什么是MVC，并且用在项目中利用Backbone.js做了实践；我参加了OO Bootcamp，终于了解了什么才是面向对象编程；我体验了敏捷开发方式：敏捷流程、持续集成、重构、自动化测试，终于体会到了先进的开发方式给整个IT行业带来的触动。&lt;/p&gt;

&lt;p&gt;细数今年那些我使用过的技术：Angular.js、Backbone.js、Sass、Compass、Rails、Redis、Responsive Design、Parallax Scrolling⋯⋯虽然并不是每个我都有非常深入的研究，但这一年是我有生以来在技术上走得最深最广的一年，感谢我的客户，我的同事们，让我感受到了代码的乐趣，借用凯桑的一句话：“Coding for fun, not coding for 饭”。&lt;/p&gt;

&lt;h3&gt;2013&lt;/h3&gt;

&lt;p&gt;从2012到2013，从一个20出头的愣头青倒向了奔往30的欧吉桑，新的一年中我希望自己有更多新的尝试，体验新的办公室，与新的同事合作，实践Lean Startup，尝试Inception，更加深入系统化的前端开发，也往移动开发方面发展⋯⋯&lt;/p&gt;

&lt;p&gt;“一转眼，前程似茧”，往年每每都会有这样那样的低谷，让我在心里默默的唱着这句歌词，而今年渐渐的淡忘了这首歌。来年回望，更上一层。&lt;/p&gt;
</content>
  </entry>
</feed>
