<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zation's Blog</title>
  <subtitle>Coding for fun</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://zation.me/"/>
  <link href="http://zation.me/feed.xml" rel="self"/>
  <updated>2015-01-15T23:54:00Z</updated>
  <author>
    <name>Zation</name>
  </author>
  <entry>
    <title>用React.js替换Backbone.js的View（二）——Todo MVC示例</title>
    <link rel="alternate" href="/2015/01/15/replace_backbonejs_view_with_reactj_2.html"/>
    <id>/2015/01/15/replace_backbonejs_view_with_reactj_2.html</id>
    <published>2015-01-15T23:54:00Z</published>
    <updated>2015-01-15T23:54:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;Backbone.js和React.js在设计思想上都借鉴了&lt;a href="http://en.wikipedia.org/wiki/Reactive_programming"&gt;Reactive Programming&lt;/a&gt;，即：当Model修改时，这种变更可以反向传播到View，使得View同时被更改，也就是双向绑定。但Backbone.js需要你自己来写如何修改View，而在React.js中，你只需要关心如何根据Model来显示View，如何修改可以完全交给React.js。也就是说他们都在做一种简化，而React.js做的更加彻底，这也是它的核心思想和优点。&lt;/p&gt;

&lt;p&gt;真正的学习还是需要写代码，所以这里用经典的&lt;a href="https://github.com/tastejs/todomvc"&gt;Todo MVC&lt;/a&gt;作为示例。所有的代码可以在我的&lt;a href="https://github.com/zation/backbone-to-react"&gt;Github&lt;/a&gt;上找到。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;Backbone.js和React.js在设计思想上都借鉴了&lt;a href="http://en.wikipedia.org/wiki/Reactive_programming"&gt;Reactive Programming&lt;/a&gt;，即：当Model修改时，这种变更可以反向传播到View，使得View同时被更改，也就是双向绑定。但Backbone.js需要你自己来写如何修改View，而在React.js中，你只需要关心如何根据Model来显示View，如何修改可以完全交给React.js。也就是说他们都在做一种简化，而React.js做的更加彻底，这也是它的核心思想和优点。&lt;/p&gt;

&lt;p&gt;真正的学习还是需要写代码，所以这里用经典的&lt;a href="https://github.com/tastejs/todomvc"&gt;Todo MVC&lt;/a&gt;作为示例。所有的代码可以在我的&lt;a href="https://github.com/zation/backbone-to-react"&gt;Github&lt;/a&gt;上找到。&lt;/p&gt;

&lt;h3&gt;环境准备&lt;/h3&gt;

&lt;p&gt;React.js推荐使用&lt;a href="http://facebook.github.io/react/docs/displaying-data.html"&gt;JSX&lt;/a&gt;来写View，所以我们需要准备一下JSX的环境。按照最简单的做法，我们只需要将in-browser JSX transformer引入即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ bower install --save react
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;index.html&lt;/code&gt;中，加入一下的代码，作为script标签的第一个：&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;script src=&amp;quot;bower_components/react/react-with-addons.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;bower_components/react/JSXTransformer.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们的JSX代码就可以在运行时编译了。&lt;/p&gt;

&lt;h3&gt;替换的方式&lt;/h3&gt;

&lt;p&gt;这里我们实际上是做的一个重构（虽然没有测试），为了尽量使得每一步都比较容易验证，我们每次commit的修改都会尽量很小，而且每次commit的代码都要保证是工作的，不会破坏原有的功能。所以我们会在原有的代码的基础上增加React.js的代码，完成一部分再删除一部分Backbone.js View的代码，最后再完成整个替换。&lt;/p&gt;

&lt;p&gt;一般来说我推荐先替换Template，再替换DOM事件的绑定和处理，最后再整体用某个Component替换掉Backbone.js View。下面我会用TodoItem View替换过程的开始部分作为示例，讲解一下如何重构，同时也讲解一些React.js的基本概念。&lt;/p&gt;

&lt;h3&gt;Template&lt;/h3&gt;

&lt;p&gt;我们之前提到过，React.js的Component其实就是View + Template的结合。那么我们应该怎样来划分Component呢？这里React.js官方给出的意见是：遵从&lt;a href="http://en.wikipedia.org/wiki/Single_responsibility_principle"&gt;单一职责的原则&lt;/a&gt;，也就是一个Component只做一件事。具体如何划分就要看你的Domain和团队自己的规则了。&lt;/p&gt;

&lt;p&gt;现在我们新建TodoItem Component，新建&lt;code&gt;todo-item.jsx&lt;/code&gt;文件，将原来template中的内容挪过来，并且用React.js的方式来render：&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;var app = app || {};

(function () {
    &amp;#39;use strict&amp;#39;;

    app.TodoItem = React.createClass({

        render: function() {
            var todoData = this.props.todo.toJSON();
            return (
                &amp;lt;div&amp;gt;
                    &amp;lt;div className=&amp;quot;view&amp;quot;&amp;gt;
                        &amp;lt;input className=&amp;quot;toggle&amp;quot; type=&amp;quot;checkbox&amp;quot; checked={todoData.completed} /&amp;gt;
                        &amp;lt;label&amp;gt;{todoData.title}&amp;lt;/label&amp;gt;
                        &amp;lt;button className=&amp;quot;destroy&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;input className=&amp;quot;edit&amp;quot; defaultValue={todoData.title} /&amp;gt;
                &amp;lt;/div&amp;gt;
            );
        }
    });
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换&lt;code&gt;todo-view.js&lt;/code&gt;中的template：&lt;/p&gt;

&lt;pre&gt;&lt;code class="diff"&gt;@@ -12,9 +12,6 @@
                //... is a list tag.
                tagName:  &amp;#39;li&amp;#39;,

-               // Cache the template function for a single item.
-               template: _.template($(&amp;#39;#item-template&amp;#39;).html()),
-
                // The DOM events specific to an item.
                events: {
                        &amp;#39;click .toggle&amp;#39;: &amp;#39;toggleCompleted&amp;#39;,
@@ -48,7 +45,9 @@
                                return;
                        }

-                       this.$el.html(this.template(this.model.toJSON()));
+                       React.render(React.createElement(app.TodoItem, {
+                               todo: this.model
+                       }), this.$el[0]);
                        this.$el.toggleClass(&amp;#39;completed&amp;#39;, this.model.get(&amp;#39;completed&amp;#39;));
                        this.toggleVisible();
                        this.$input = this.$(&amp;#39;.edit&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们用到了React.js Component的&lt;code&gt;props&lt;/code&gt;属性，这个属性是由父Component传下来的数据，&lt;code&gt;props&lt;/code&gt;本身是不可以由子Component自己去改变的，后面我们会讲到，对用户操作会改变的数据，应该使用&lt;code&gt;state&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;index.html&lt;/code&gt;中删除原有的模板，引入&lt;code&gt;todo-item.jsx&lt;/code&gt;，同时用JSXTransformer来管理所有View的加载：&lt;/p&gt;

&lt;pre&gt;&lt;code class="diff"&gt;@@ -23,16 +23,6 @@
            &amp;lt;p&amp;gt;Written by &amp;lt;a href=&amp;quot;https://github.com/addyosmani&amp;quot;&amp;gt;Addy Osmani&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;Part of &amp;lt;a href=&amp;quot;http://todomvc.com&amp;quot;&amp;gt;TodoMVC&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;/footer&amp;gt;
-       &amp;lt;script type=&amp;quot;text/template&amp;quot; id=&amp;quot;item-template&amp;quot;&amp;gt;
-           &amp;lt;div&amp;gt;
-               &amp;lt;div class=&amp;quot;view&amp;quot;&amp;gt;
-                   &amp;lt;input class=&amp;quot;toggle&amp;quot; type=&amp;quot;checkbox&amp;quot; &amp;lt;%= completed ? &amp;#39;checked&amp;#39; : &amp;#39;&amp;#39; %&amp;gt;&amp;gt;
-                   &amp;lt;label&amp;gt;&amp;lt;%- title %&amp;gt;&amp;lt;/label&amp;gt;
-                   &amp;lt;button class=&amp;quot;destroy&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
-               &amp;lt;/div&amp;gt;
-               &amp;lt;input class=&amp;quot;edit&amp;quot; value=&amp;quot;&amp;lt;%- title %&amp;gt;&amp;quot;&amp;gt;
-           &amp;lt;/div&amp;gt;
-       &amp;lt;/script&amp;gt;
        &amp;lt;script type=&amp;quot;text/template&amp;quot; id=&amp;quot;stats-template&amp;quot;&amp;gt;
            &amp;lt;span id=&amp;quot;todo-count&amp;quot;&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;%= remaining %&amp;gt;&amp;lt;/strong&amp;gt; &amp;lt;%= remaining === 1 ? &amp;#39;item&amp;#39; : &amp;#39;items&amp;#39; %&amp;gt; left&amp;lt;/span&amp;gt;
            &amp;lt;ul id=&amp;quot;filters&amp;quot;&amp;gt;

@@ -52,16 +42,16 @@
        &amp;lt;script src=&amp;quot;js/models/todo.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src=&amp;quot;js/collections/todos.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
-       &amp;lt;script src=&amp;quot;js/views/todo-view.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
-       &amp;lt;script src=&amp;quot;js/views/app-view.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
-       &amp;lt;script src=&amp;quot;js/routers/router.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
-       &amp;lt;script src=&amp;quot;js/app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
+       &amp;lt;script type=&amp;quot;text/jsx&amp;quot; src=&amp;quot;js/components/todo-item.jsx&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
+       &amp;lt;script type=&amp;quot;text/jsx&amp;quot; src=&amp;quot;js/views/todo-view.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
+       &amp;lt;script type=&amp;quot;text/jsx&amp;quot; src=&amp;quot;js/views/app-view.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
+       &amp;lt;script type=&amp;quot;text/jsx&amp;quot; src=&amp;quot;js/routers/router.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
+       &amp;lt;script type=&amp;quot;text/jsx&amp;quot; src=&amp;quot;js/app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
 &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里，替换就告一段落了。这个时候我们可以看到原有的功能都是可工作的，现在就可以做一个提交了。&lt;/p&gt;

&lt;h3&gt;DOM事件&lt;/h3&gt;

&lt;p&gt;下面我们开始把DOM事件的处理挪到&lt;code&gt;todo-item.jsx&lt;/code&gt;中，并且以React.js的方式来做。以toggle为例：&lt;/p&gt;

&lt;pre&gt;&lt;code class="diff"&gt;index js/components/todo-item.jsx
@@ -5,12 +5,28 @@
    app.TodoItem = React.createClass({

+       getInitialState: function() {
+           return {
+               completed: this.props.todo.get(&amp;#39;completed&amp;#39;)
+           };
+       },
+
+       // Toggle the `&amp;quot;completed&amp;quot;` state of the model.
+       toggleCompleted: function () {
+           this.setState({
+               completed: this.props.todo.toggle()
+           });
+       },
+
        render: function() {
            var todoData = this.props.todo.toJSON();
            return (
                &amp;lt;div&amp;gt;
                    &amp;lt;div className=&amp;quot;view&amp;quot;&amp;gt;
-                       &amp;lt;input className=&amp;quot;toggle&amp;quot; type=&amp;quot;checkbox&amp;quot; checked={todoData.completed} /&amp;gt;
+                       &amp;lt;input className=&amp;quot;toggle&amp;quot;
+                           type=&amp;quot;checkbox&amp;quot;
+                           checked={this.state.completed}
+                           onChange={this.toggleCompleted}/&amp;gt;
                        &amp;lt;label&amp;gt;{todoData.title}&amp;lt;/label&amp;gt;
                        &amp;lt;button className=&amp;quot;destroy&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
                    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="diff"&gt;index js/models/todo.js
@@ -18,9 +18,11 @@
        // Toggle the `completed` state of this todo item.
        toggle: function () {
+           var completed = !this.get(&amp;#39;completed&amp;#39;);
            this.save({
-               completed: !this.get(&amp;#39;completed&amp;#39;)
+               completed: completed
            });
+           return completed;
        }
    });
 })();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="diff"&gt;index js/views/todo-view.js
@@ -14,7 +14,6 @@
        // The DOM events specific to an item.
        events: {
-           &amp;#39;click .toggle&amp;#39;: &amp;#39;toggleCompleted&amp;#39;,
            &amp;#39;dblclick label&amp;#39;: &amp;#39;edit&amp;#39;,
            &amp;#39;click .destroy&amp;#39;: &amp;#39;clear&amp;#39;,
            &amp;#39;keypress .edit&amp;#39;: &amp;#39;updateOnEnter&amp;#39;,
@@ -64,11 +63,6 @@
                app.TodoFilter === &amp;#39;completed&amp;#39;;
        },

-       // Toggle the `&amp;quot;completed&amp;quot;` state of the model.
-       toggleCompleted: function () {
-           this.model.toggle();
-       },
-
        // Switch this view into `&amp;quot;editing&amp;quot;` mode, displaying the input field.
        edit: function () {
            this.$el.addClass(&amp;#39;editing&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里toggle事件就被重构完成了。我们引入了一个新的概念，就是&lt;code&gt;state&lt;/code&gt;。我们之前提到过，&lt;code&gt;state&lt;/code&gt;是用来表示Component中，用户通过操作可能改变的数据。关于&lt;code&gt;state&lt;/code&gt;和&lt;code&gt;props&lt;/code&gt;的详细区别，这里有一篇文章（&lt;a href="https://github.com/uberVU/react-guide/blob/master/props-vs-state.md"&gt;props vs state&lt;/a&gt;）介绍得很好，这里把最关键的部分转载并翻译一下：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;&lt;em&gt;props&lt;/em&gt;&lt;/th&gt;
&lt;th&gt;&lt;em&gt;state&lt;/em&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;能否从&lt;strong&gt;父&lt;/strong&gt;Component获取初始值?&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;父&lt;/strong&gt;Component中的值改变，是否会影响自身的值?&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;能否在自身中设置默认值?^&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;能否在自身中改变值?&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;能否给子Component设置默认值?&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自身的值改变，是否会影响传给子Component中的值?&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;^ 注意：props和state的默认值，都会被父Component传过来的默认值覆盖。&lt;/p&gt;

&lt;h3&gt;DOM操作&lt;/h3&gt;

&lt;p&gt;在View这一层，我们常常会有针对某个Element进行操作的需求，以前我们可能会通过Class、ID或Tag来获取到这个Element，然后调用DOM方法来操作它。而React.js提供了&lt;code&gt;refs&lt;/code&gt;来完成这个功能：&lt;/p&gt;

&lt;pre&gt;&lt;code class="diff"&gt;index js/components/todo-item.jsx
@@ -18,6 +18,11 @@
            });
        },

+       // Switch this view into `&amp;quot;editing&amp;quot;` mode, displaying the input field.
+       edit: function () {
+           this.refs.editInput.getDOMNode().focus();
+       },
+
        render: function() {
            var todoData = this.props.todo.toJSON();
            return (
@@ -27,10 +32,10 @@
                            type=&amp;quot;checkbox&amp;quot;
                            checked={this.state.completed}
                            onChange={this.toggleCompleted}/&amp;gt;
-                       &amp;lt;label&amp;gt;{todoData.title}&amp;lt;/label&amp;gt;
+                       &amp;lt;label onDoubleClick={this.edit}&amp;gt;{todoData.title}&amp;lt;/label&amp;gt;
                        &amp;lt;button className=&amp;quot;destroy&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
                    &amp;lt;/div&amp;gt;
-                   &amp;lt;input className=&amp;quot;edit&amp;quot; defaultValue={todoData.title} /&amp;gt;
+                   &amp;lt;input ref=&amp;quot;editInput&amp;quot; className=&amp;quot;edit&amp;quot; defaultValue={todoData.title} /&amp;gt;
                &amp;lt;/div&amp;gt;
            );
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="diff"&gt;index js/views/todo-view.js
@@ -66,7 +66,6 @@
        // Switch this view into `&amp;quot;editing&amp;quot;` mode, displaying the input field.
        edit: function () {
            this.$el.addClass(&amp;#39;editing&amp;#39;);
-           this.$input.focus();
        },

        // Close the `&amp;quot;editing&amp;quot;` mode, saving changes to the todo.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里之所以React.js专门提供了refs，而没有推荐使用传统方式，我觉得是因为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;避免多余的class或ID，这样我们可以将class只用于样式上，将ID只用于form中，让他们的使用更加符合原始的设计；&lt;/li&gt;
&lt;li&gt;refs返回的其实不单是DOM对象，而是一个称为“backing instance”的东西，这个我没有查到具体含义是什么，猜测应该是React.js中Virtual DOM中的实例。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;此间省略N步，我们得到了最后的&lt;a href="https://github.com/zation/backbone-to-react"&gt;重构成果&lt;/a&gt;，如果希望看中间过程的，可以查看中间的commit diff。&lt;/p&gt;

&lt;p&gt;在替换前后之间，我们可以比较一下监听事件的不同，首先来看看替换前我们监听了哪些事件：&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;//todo-view.js
...
initialize: function () {
    this.listenTo(this.model, &amp;#39;change&amp;#39;, this.render);
    this.listenTo(this.model, &amp;#39;destroy&amp;#39;, this.remove);
    this.listenTo(this.model, &amp;#39;visible&amp;#39;, this.toggleVisible);
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;//app-view.js
...
initialize: function () {
...
    this.listenTo(app.todos, &amp;#39;add&amp;#39;, this.addOne);
    this.listenTo(app.todos, &amp;#39;reset&amp;#39;, this.addAll);
    this.listenTo(app.todos, &amp;#39;change:completed&amp;#39;, this.filterOne);
    this.listenTo(app.todos, &amp;#39;filter&amp;#39;, this.filterAll);
    this.listenTo(app.todos, &amp;#39;all&amp;#39;, this.render);
...
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们可以全文搜索一下替换后的事件监听，只剩下一个：&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;//app.js
...
app.todos.on(&amp;#39;all&amp;#39;, render);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，不管数据如何变化，不管哪些数据变化了，我都直接拿我关心的数据来render就完了。由于Virtual DOM帮我做了增量式的DOM修改，这一部分就不用我来操心了，那么之前的一大堆事件监听以及相应的事件处理回调都可以省略了，这样代码逻辑的复杂度会降低很多，可维护和可读性会提高很多，同时也没有性能的担忧。React.js真是处理Tempate和View的一大神器啊！&lt;/p&gt;

&lt;p&gt;而且重构到最后我发现，如果不是因为Backbone.js的router依赖于jQuery，连jQuery我都可以直接删了。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>用React.js替换Backbone.js的View（一）——Backbone.js View的陷阱以及React.js的优点</title>
    <link rel="alternate" href="/2015/01/13/replace_backbonejs_view_with_reactj_1.html"/>
    <id>/2015/01/13/replace_backbonejs_view_with_reactj_1.html</id>
    <published>2015-01-13T14:25:00Z</published>
    <updated>2015-01-13T14:25:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;最近终于找到时间，学习了一下Facebook出品的&lt;a href="http://facebook.github.io/react/"&gt;React.js&lt;/a&gt;，发现虽然没有很深的体会到性能上的好处，但是这种编程方式带来的好处确实是很大的。这里我准备跟Backbone.js的View做一下对比，同时下一篇文章中提供一个示例说明一下如何用React.js替换Backbone.js的View。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;最近终于找到时间，学习了一下Facebook出品的&lt;a href="http://facebook.github.io/react/"&gt;React.js&lt;/a&gt;，发现虽然没有很深的体会到性能上的好处，但是这种编程方式带来的好处确实是很大的。这里我准备跟Backbone.js的View做一下对比，同时下一篇文章中提供一个示例说明一下如何用React.js替换Backbone.js的View。&lt;/p&gt;

&lt;h3&gt;Backbone.js中View的陷阱&lt;/h3&gt;

&lt;p&gt;这里用陷阱这个词，是因为下面这些其实并不是Backbone.js本身所引发的问题，但却是使用Backbone.js的View时，常常会犯的错误。&lt;/p&gt;

&lt;h4&gt;绑定的事件没有解绑而造成的内存泄露&lt;/h4&gt;

&lt;p&gt;对于某个View，如果在它内部绑定事件的方式不正确，会造成&lt;code&gt;remove&lt;/code&gt;的时候没有解绑，最后造成内存泄露。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var SomeModelView = Backbone.View.extend({
    initialize: function() {
        this.model.on(&amp;#39;change&amp;#39;, this.render, this);
    },
    render: function() {
        // render a template
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有两种方式可以解决这个问题，第一个是使用&lt;code&gt;listenTo&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var SomeModelView = Backbone.View.extend({
    initialize: function() {
        this.listenTo(this.model, &amp;#39;change&amp;#39;, this.render);
    },
    render: function() {
        // render a template
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个是显式的在&lt;code&gt;close&lt;/code&gt;方法中解绑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var SomeModelView = Backbone.View.extend({
    initialize: function() {
        this.model.on(&amp;#39;change&amp;#39;, this.render, this);
    },
    close: function() {
        this.model.off(&amp;#39;change&amp;#39;, this.render);
    },
    render: function() {
        // render a template
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;如果没有特殊情况，都推荐使用第一种解决方案。&lt;/p&gt;

&lt;p&gt;其实以上的问题还不是真正的麻烦，真正的麻烦在于所有的View都需要以调用&lt;code&gt;remove&lt;/code&gt;的方式来删除，否则不仅是model或collection上面的事件无法解绑，DOM事件都会没有解绑，从而造成事件重复绑定或内存泄露的问题。而对于一个Backbone.js的应用来说，一个View有十多个内嵌了N层的SubView是很正常的情况，如何保证这些SubView都被remove掉了是非常大的问题，例如在切换页面的时候，需要首先删除一个页面级别的View再插入另一个。&lt;a href="http://mikeygee.com/blog/backbone.html"&gt;这里&lt;/a&gt;有一篇文章详细叙述了如何解决这个问题，我这里就不复述了。&lt;/p&gt;

&lt;h4&gt;DOM的render可能效率很低&lt;/h4&gt;

&lt;p&gt;如果多次使用append来插入SubView，由于每次都会导致浏览器重新计算Element的位置和大小，所以可能效率会很低，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var SomeCollectionView = Backbone.View.extend({
    initialize: function() {
        var self = this;
        this._views = [];
        // create a sub view for every model in the collection
        this.collection.each(function(model) {
            self._views.push(new SomeModelView({
                model: model
            }));
        });
    },
    render: function() {
        var self = this;
        this.$el.empty();
        // render each subview, appending to our root element
        _.each(this._views, function(subview) {
            self.$el.append(subview.render().el);
        });
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候我们可以使用&lt;code&gt;documentFragment&lt;/code&gt;来在内存中先把我们要插入的DOM组织好，再一次性的完成append操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;render: function() {
    this.$el.empty();
    var container = document.createDocumentFragment();
    // render each subview, appending to our root element
    _.each(this._views, function(subview) {
        container.appendChild(subview.render().el)
    });
    this.$el.append(container);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来这也不是真正麻烦的问题，至少我们还有解决方案，但是如果是一个大量数据的collection需要render，那么就需要我们自己在render的时候做增量式的操作，否则效率无论如何都提高不起来，这往往在老的浏览器或者移动端是无法接受的。&lt;/p&gt;

&lt;h3&gt;React.js的优点&lt;/h3&gt;

&lt;p&gt;如果我们有一个跟Backbone.js同样轻量级，并且又自己解决了以上问题的框架，我们为什么不试试看呢？&lt;/p&gt;

&lt;h4&gt;Virtual DOM&lt;/h4&gt;

&lt;p&gt;是的，所有的问题都可以使用一个Virtual DOM来解决。这个Virtual DOM由React.js来维护，每次对于DOM的修改都是增量式的，效率会非常高。并且对于删除的DOM，它上面的DOM事件会自动删除，不需要我们显式的调用一次，并且对于DOM的删除操作不需要显示的调用&lt;code&gt;remove&lt;/code&gt;，一切有React.js来搞定。&lt;/p&gt;

&lt;p&gt;这样就避免了很多内存泄露的可能性，也大大提高了性能。也就是同时解决了之前的两个问题。&lt;/p&gt;

&lt;h4&gt;Template与View不再分离&lt;/h4&gt;

&lt;p&gt;在大多数人的观念中，Template和View是完全不同的两种事物：一个是显示的内容，一个是显示的逻辑；一个是HTML，一个是JS。但是我们在实际开发的过程中，往往是开了两个窗口，左边是Template，右边是View，我们会非常欢快的在两边频繁切换。我们会做这样的操作，就是因为View的逻辑，就是Template的逻辑；Template的内容，其实也是View的内容。这两者没有大家想想的那么大的区别，分开以后反而是导致了代码不易读的问题，我常常会为了了解Template中的一个显示是如何得到的，而在各种View中找半天。&lt;/p&gt;

&lt;p&gt;Template与View的合并带来了代码可读性的提高，但是可能也有人会觉得把这两种合并到一起会让代码变得更加臃肿。这里就要提到React.js的Component这个概念了，有了Component的细化，其实每一个Component的代码是很独立，并且也很少的。&lt;/p&gt;

&lt;h4&gt;Component&lt;/h4&gt;

&lt;p&gt;Compnent这个概念的出现，就是为了使得页面组件可以更加容易的被重用。在React.js给出的官方&lt;a href="http://facebook.github.io/react/docs/thinking-in-react.html"&gt;示例中&lt;/a&gt;，我们可以看到Component的粒度可以非常细，同时可以利用&lt;a href="http://facebook.github.io/react/docs/transferring-props.html"&gt;Props&lt;/a&gt;来保证Component之间的解耦。&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;有了Virtual DOM，JSX（合并Template与View），Component这三大利器，React.js现在已经成为了Template和View这一层的不二框架了。再加上它本身的轻量级，还有Facebook来维护，采用它的风险可以说非常低。由于以上种种原因，是的一个两年不到的项目，在Github上有了13,120的Star数量，社区也提供了相当的热情&lt;/p&gt;

&lt;h3&gt;一些资料&lt;/h3&gt;

&lt;p&gt;下面是一些关于React.js的资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=-DX3vJiqxm4"&gt;Pete Hunt - The Secrets of React&amp;#39;s Virtual DOM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/21109361/why-is-reacts-concept-of-virtual-dom-said-to-be-more-performant-than-dirty-mode"&gt;Why is React&amp;#39;s concept of Virtual DOM said to be more performant than dirty model checking?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://calendar.perfplanet.com/2013/diff/"&gt;React’s diff algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>编写易读、可测试、可运行的API文档</title>
    <link rel="alternate" href="/2014/12/09/readable_testable_runnable_API_documentation.html"/>
    <id>/2014/12/09/readable_testable_runnable_API_documentation.html</id>
    <published>2014-12-09T03:31:00Z</published>
    <updated>2014-12-09T03:31:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img title="Document" alt="Document" src="/images/document.jpg?1418545547" /&gt;&lt;/p&gt;

&lt;p&gt;自从开放的API接口在社交媒体以及Web 2.0中运用的越来越广泛，API已经成为了互联网产品的标准配置。并且不光是对外提供API，对于前后端分离的应用，API也是非常重要的一部分。编写一个好的API，不光是代码写得好，最重要的是文档写得好。但是我们在写文档的时候尝尝会遇到下面几个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有统一的编写规范，这样不同的人在维护的时候尝尝会导致文档越来越乱，最终无法继续维护，也无法阅读。&lt;/li&gt;
&lt;li&gt;API修改以后，文档没有跟着改，或者改错了，导致API的使用者无法正常调用。&lt;/li&gt;
&lt;li&gt;作为前端开发，往往是在API开发完成以前，就要根据API的文档准备一些mock data来帮助开发，如果API文档可以直接生成一个mock server，就会非常方便&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们来看看如何构建能够解决以上问题的，完美的文档。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;img title="Document" alt="Document" src="/images/document.jpg?1418545547" /&gt;&lt;/p&gt;

&lt;p&gt;自从开放的API接口在社交媒体以及Web 2.0中运用的越来越广泛，API已经成为了互联网产品的标准配置。并且不光是对外提供API，对于前后端分离的应用，API也是非常重要的一部分。编写一个好的API，不光是代码写得好，最重要的是文档写得好。但是我们在写文档的时候尝尝会遇到下面几个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有统一的编写规范，这样不同的人在维护的时候尝尝会导致文档越来越乱，最终无法继续维护，也无法阅读。&lt;/li&gt;
&lt;li&gt;API修改以后，文档没有跟着改，或者改错了，导致API的使用者无法正常调用。&lt;/li&gt;
&lt;li&gt;作为前端开发，往往是在API开发完成以前，就要根据API的文档准备一些mock data来帮助开发，如果API文档可以直接生成一个mock server，就会非常方便&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们来看看如何构建能够解决以上问题的，完美的文档。&lt;/p&gt;

&lt;h3&gt;API Blueprint&lt;/h3&gt;

&lt;p&gt;所谓没有规矩，不成方圆。现在我要介绍的，就是一个API文档的规范：&lt;a href="https://apiblueprint.org/"&gt;API Blueprint&lt;/a&gt;。这个文档规范有以下的特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基于&lt;a href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt;，所以比较容易上手，同时机器和人都容易理解。&lt;/li&gt;
&lt;li&gt;由于是纯文本，所以可以进行版本管理。&lt;/li&gt;
&lt;li&gt;有非常多的相关工具，可以转为HTML，可以测试，可以作为Mock Server运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里是API Blueprint的&lt;a href="https://github.com/apiaryio/api-blueprint/blob/master/API%20Blueprint%20Specification.md"&gt;格式文档&lt;/a&gt;，如果觉得字太多了不好理解，这里还有一个&lt;a href="https://github.com/apiaryio/api-blueprint/blob/master/Tutorial.md"&gt;简化的教程&lt;/a&gt;。下面是一个简单的实例，包含了基本的元素及其说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 这里是API的名字
这里是API的描述

## 这里是Resource的名字 [/uri/to/resouce]
这里是Resource的描述

### 这里是Action的名字，后面跟Type [GET]
这里是Action的描述，下面就是Request与Response的示例了

+ Response 200

    + Headers

        Content-Type: application/json

    + Body

        {
            &amp;quot;id&amp;quot;: 1
            &amp;quot;name&amp;quot;: &amp;quot;some name&amp;quot;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们有了一份基本的API文档了，下面我们来介绍如何让这份文档更加可读，并且可以测试和运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;下面我会使用一个更加真实的&lt;a href="https://github.com/danielgtaylor/aglio/blob/master/example.md"&gt;API文档示例&lt;/a&gt;，并且之后所有的代码都可以在&lt;a href="https://github.com/zation/API-blueprint-demo"&gt;这里&lt;/a&gt;下载。&lt;/p&gt;

&lt;h3&gt;转化为更加易读的HTML页面&lt;/h3&gt;

&lt;p&gt;API Blueprint现在有两个开源工具可以生成静态HTML：&lt;a href="https://github.com/danielgtaylor/aglio"&gt;aglio&lt;/a&gt;和&lt;a href="https://github.com/subosito/iglo"&gt;iglo&lt;/a&gt;，这里使用aglio作为示例。并且为了我们可以实时的看到修改以后生成的HTML，我们同时引入了gulp作为实时的构建工具。&lt;/p&gt;

&lt;p&gt;首先，我们定义一个task，命名为document，用来生成HTML，以及实时刷新页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;#39;use strict&amp;#39;;

var gulp = require(&amp;#39;gulp&amp;#39;);
var aglio = require(&amp;#39;gulp-aglio&amp;#39;);
var connect = require(&amp;#39;gulp-connect&amp;#39;);
var watch = require(&amp;#39;gulp-watch&amp;#39;);

gulp.task(&amp;#39;document&amp;#39;, function() {
  return gulp.src([&amp;#39;documents/API.md&amp;#39;])
    .pipe(watch(&amp;#39;documents/API.md&amp;#39;))
    .pipe(aglio({template: &amp;#39;default&amp;#39;, filename: &amp;#39;./.tmp/index.html&amp;#39;}))
    .pipe(gulp.dest(&amp;#39;./.tmp/&amp;#39;))
    .pipe(connect.reload());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，我们创建一个task来启动静态页面服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gulp.task(&amp;#39;server&amp;#39;, function() {
  return connect.server({
    root: [&amp;#39;./.tmp&amp;#39;],
    port: 3456,
    livereload: {
      port: 35728
    }
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，为了方便，我们加上一个自动打开该静态页面的task：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gopen = require(&amp;#39;gulp-open&amp;#39;);

gulp.task(&amp;#39;open&amp;#39;, function() {
  return gulp.src(&amp;#39;./gulpfile.js&amp;#39;)
    .pipe(gopen(&amp;#39;&amp;#39;, {
      url: &amp;#39;http://localhost:3456&amp;#39;
    }));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，把上面的task加到默认的gulp task中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;server&amp;#39;, &amp;#39;document&amp;#39;, &amp;#39;open&amp;#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，可以运行&lt;code&gt;gulp&lt;/code&gt;来自动生成HTML的task了，并且浏览器会自动打开该页面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于aglio请求了很多外部静态资源，特别是google font，所以可能页面会打不开，我们可以写自己的template修正这个问题。&lt;/li&gt;
&lt;li&gt;由于aglio的一些依赖的需求，它只能运行在Node 11.10之前，建议使用Node 10.*。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;模块化的管理API文档&lt;/h3&gt;

&lt;p&gt;我们看到现在的API.md文件有283行，这还是只包含了三个group的。如果API的数量更多，那么全都写在一个markdown文件中会非常难以维护。这个时候我们就需要把一个markdown文件，拆分成多个，并且gulp脚本也需要一定的处理。&lt;/p&gt;

&lt;p&gt;首先，我们将API.md按照group，拆分为notes.md、users.md、tags.md。然后，我们需要在脚本中将这几个文件生成为一个，所以我们需要修改document task：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&amp;#39;gulp&amp;#39;);
var aglio = require(&amp;#39;gulp-aglio&amp;#39;);
var connect = require(&amp;#39;gulp-connect&amp;#39;);
var continuousConcat = require(&amp;#39;gulp-continuous-concat&amp;#39;);
var watch = require(&amp;#39;gulp-watch&amp;#39;);

gulp.task(&amp;#39;document&amp;#39;, function() {
  return gulp.src([&amp;#39;documents/API.md&amp;#39;, &amp;#39;documents/*.md&amp;#39;])
    .pipe(watch(&amp;#39;documents/*.md&amp;#39;))
    .pipe(continuousConcat(&amp;#39;API.md&amp;#39;))
    .pipe(aglio({template: &amp;#39;default&amp;#39;, filename: &amp;#39;./.tmp/index.html&amp;#39;}))
    .pipe(gulp.dest(&amp;#39;./.tmp/&amp;#39;))
    .pipe(connect.reload());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;这里使用&lt;code&gt;gulp-continuous-concat&lt;/code&gt;而没有使用&lt;code&gt;gulp-concat&lt;/code&gt;，是因为后者只在stream结束的时候才真的进行concat，这样就没有办法跟&lt;code&gt;gulp-watch&lt;/code&gt;一起用了，因为&lt;code&gt;gulp-watch&lt;/code&gt;是会让stream永久运行的。而&lt;code&gt;gulp-continuous-concat&lt;/code&gt;就没有这个限制。&lt;/p&gt;

&lt;h3&gt;将API文档作为Mock Server&lt;/h3&gt;

&lt;p&gt;作为一个前端开发，可能一个最头痛的问题就是与API的集成了。在实际开发的过程中，前后端会按照相互之间商量好的API分别开发，最后再集成到一起。但是后台API是尝尝会改动的，所以我们会遇到两个问题：后台改动后没有通知前端；后台修改并且通知后，前端没有修改mock的数据。这两种情况的结果都是集成失败，并且有可能前端需要一定的返工。&lt;/p&gt;

&lt;p&gt;那么怎么样才可以避免这个问题呢？只要我们保证文档就是Mock Server的数据来源，那么后台对于文档的任何修改，前端在开发过程中肯定会立刻知晓，并且也会反应在Mock Data上面。这也是我选用Api Blueprint的一大原因。下面我们来看看如何将API文档作为Mock Server启动起来。&lt;/p&gt;

&lt;p&gt;实际上非常简单，只需要安装&lt;code&gt;api-mock&lt;/code&gt;，然后运行&lt;code&gt;api-mock xxx.md&lt;/code&gt;就可以了。但是由于我们之前将文档拆分了，那么在启动之前需要我们先build一份完整的文档出来，所以我们需要在gulp脚本中加入下面这个task：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var connect = require(&amp;#39;gulp-connect&amp;#39;);

gulp.task(&amp;#39;build&amp;#39;, function() {
  return gulp.src([&amp;#39;documents/API.md&amp;#39;, &amp;#39;documents/*.md&amp;#39;])
    .pipe(concat(&amp;#39;API.md&amp;#39;))
    .pipe(gulp.dest(&amp;#39;./.tmp/&amp;#39;));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后为了方便运行，可以修改&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scrips&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;scripts&amp;quot;: {
  &amp;quot;start&amp;quot;: &amp;quot;gulp build &amp;amp;&amp;amp; api-mock ./.tmp/API.md --port 3457&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行&lt;code&gt;npm start&lt;/code&gt;就可以启动Mock Server了，你可以访问&lt;a href="http://localhost:3457/notes/1"&gt;http://localhost:3457/notes/1&lt;/a&gt;来测试一下。&lt;/p&gt;

&lt;h3&gt;测试你的文档&lt;/h3&gt;

&lt;p&gt;最后，我们还剩下唯一一个问题，就是如何保证我们的API文档与真实的API是一致的？自动化测试是一个有效的保证，&lt;a href="https://github.com/apiaryio/dredd"&gt;Dredd&lt;/a&gt;就是这样一个基于API Blueprint提供自动化测试的工具。&lt;/p&gt;

&lt;p&gt;Dredd的使用也很方便，只需要运行&lt;code&gt;dredd xxx.md http://url/to/api-server&lt;/code&gt;就可以了。为了方便，我们可以把测试脚本放在&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scripts&lt;/code&gt;中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;scripts&amp;quot;: {
  &amp;quot;test&amp;quot;: &amp;quot;gulp build &amp;amp;&amp;amp; dredd ./.tmp/API.md http://localhost:3458&amp;quot;,
  &amp;quot;start&amp;quot;: &amp;quot;gulp build &amp;amp;&amp;amp; api-mock ./.tmp/API.md --port 3457&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时我用express创建了一个简单的后台，使用&lt;code&gt;node server.js&lt;/code&gt;就可以启动，然后就可以运行&lt;code&gt;npm test&lt;/code&gt;查看文档测试的结果了。&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;虽然我们有了一个非常完美的文档系统，但是文档的本质作用是用于沟通，如果团队内部相互沟通的意愿不强烈，那么再好的工具没有办法用好，也不可能使用某个工具就可以建立起沟通的意愿。所以在团队建设的过程中，沟通、优化、负责等等好的意愿的建立是首位的，然后才是寻找到适合团队的工具来帮助解决问题，更好的发挥意愿。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>国内项目天坑记（二）——Gruntfile的模块化</title>
    <link rel="alternate" href="/2014/06/09/grunt_config_as_modules.html"/>
    <id>/2014/06/09/grunt_config_as_modules.html</id>
    <published>2014-06-09T15:31:00Z</published>
    <updated>2014-06-09T15:31:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;在大型项目中用过Grunt的都知道，当自动化的配置和task多了一个，一个Gruntfile.js文件可能有好几百行，这样维护非常困难，于是对Gruntfile的模块化势在必行。感谢&lt;a href="http://zhuanlan.zhihu.com/tla42"&gt;墨磊&lt;/a&gt;同学帮助我们做了模块化！以下内容都是他的实践。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;在大型项目中用过Grunt的都知道，当自动化的配置和task多了一个，一个Gruntfile.js文件可能有好几百行，这样维护非常困难，于是对Gruntfile的模块化势在必行。感谢&lt;a href="http://zhuanlan.zhihu.com/tla42"&gt;墨磊&lt;/a&gt;同学帮助我们做了模块化！以下内容都是他的实践。&lt;/p&gt;

&lt;p&gt;本质上Gruntfile.js就是一个node.js代码文件，所以我们可以很方便的用&lt;a href="http://www.commonjs.org"&gt;CommonJS&lt;/a&gt;的规范将Gruntfile.js模块化。下面我们首先来看看模块化以后的grunt目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Gruntfile.js
grunt/
    compile/
        compass.js
        concat.js
        uglify.js
        ...
    dev/
        jshint.js
        connect.js
        ...
    config.js
    tasks.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里要提一下grunt模块划分，一般是根据task的不同来划分的。而&lt;a href="http://gulpjs.com/"&gt;gulp&lt;/a&gt;是根据处理的文件类型的不同来划分的。&lt;/p&gt;

&lt;p&gt;Gruntfile.js所做的事情就很简单了，只是加载tasks.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;#39;use strict&amp;#39;;

module.exports = function (grunt) {
    // load tasks
    require(&amp;#39;./grunt/tasks.js&amp;#39;)(grunt);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tasks.js负责加载和注册所有的tasks和config.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function (grunt) {

    require(&amp;#39;./config.js&amp;#39;)(grunt);

    grunt.loadTasks(&amp;#39;./grunt/compile&amp;#39;);
    grunt.loadTasks(&amp;#39;./grunt/dev&amp;#39;);

    grunt.registerTask(&amp;#39;some tasks&amp;#39;, function () {
        //...
    });

    return grunt;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这里&lt;code&gt;grunt.loadTasks()&lt;/code&gt;方法的路径是相对于Gruntfile.js的。&lt;/p&gt;

&lt;p&gt;config.js负责配置项目相关的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function (grunt) {
    grunt.initConfig({
        // configurable paths
        server: {
            hostname: &amp;#39;0.0.0.0&amp;#39;,
            hostport: &amp;#39;9000&amp;#39;
        },
        testServer: {
            hostname: &amp;#39;localhost&amp;#39;,
            hostport: &amp;#39;9001&amp;#39;
        },
        yeoman: {
            app: &amp;#39;app&amp;#39;,
            dist: &amp;#39;dist&amp;#39;,
            test: &amp;#39;test&amp;#39;,
            tmp: &amp;#39;.tmp&amp;#39;
        }
    });

    return grunt;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;compile文件夹下的tasks是在build production package的时候用到的，dev文件夹下的tasks是在开发环境中用到的，这里也可以根据项目的实际情况进行分类。&lt;/p&gt;

&lt;p&gt;这里我认为还可以做优化的地方在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用.json配置文件代替.js配置文件，并且预先设订好对于不同环境的配置文件，例如：config.json.development, config.json.production, config.json.staging, config.json.test&amp;hellip; 不同的环境中就使用不同的配置文件，这样让所有的配置文件都可以做版本管理，而且也更加统一。&lt;/li&gt;
&lt;li&gt;使用npm将这些配置代码都打包，放到另一个独立的github repo中，这样可以简化项目结构和代码，同时也利于这些代码在其他项目中的共用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些优化我已经在新的项目中进行过尝试了，效果挺不错的，后面会写一篇更加详细的文章来进行介绍。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>国内项目天坑记（一）——大型官方网站中的前端选型</title>
    <link rel="alternate" href="/2014/06/05/frontend_architecture_in_a_large_corp_portal_site.html"/>
    <id>/2014/06/05/frontend_architecture_in_a_large_corp_portal_site.html</id>
    <published>2014-06-05T13:08:00Z</published>
    <updated>2014-06-05T13:08:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img title="Architecture" alt="Architecture" src="/images/architecture.jpg?1402338328" /&gt;&lt;/p&gt;

&lt;p&gt;一年多的时间没有写博客了，这段时间一直在加班加点的赶一个国内官方网站项目，基本12*6的工作时间让博客荒废了这么久，现在终于有些时间总结整理一下这个项目中的一些坑和经验。之所以叫做天坑记而不是填坑记，是因为该坑连绵不绝，是一个堪称有生之年的坑……&lt;/p&gt;

&lt;p&gt;项目开始的初期，面临着很多许多技术选型，选的好可以让后面的开发事半功倍，选的不好……就只能自己埋的坑自己填了。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;img title="Architecture" alt="Architecture" src="/images/architecture.jpg?1402338328" /&gt;&lt;/p&gt;

&lt;p&gt;一年多的时间没有写博客了，这段时间一直在加班加点的赶一个国内官方网站项目，基本12*6的工作时间让博客荒废了这么久，现在终于有些时间总结整理一下这个项目中的一些坑和经验。之所以叫做天坑记而不是填坑记，是因为该坑连绵不绝，是一个堪称有生之年的坑……&lt;/p&gt;

&lt;p&gt;项目开始的初期，面临着很多许多技术选型，选的好可以让后面的开发事半功倍，选的不好……就只能自己埋的坑自己填了。&lt;/p&gt;

&lt;h3&gt;选型的注意事项&lt;/h3&gt;

&lt;p&gt;现在回过头来看，做技术选型有下面几个要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不要选择团队不熟悉的技术。即使一些新的技术看起来非常诱人又具有挑战性，除非团队中有牛人签了卖身契和军令状保证可以搞定因为新技术所产生的问题。实在逼不得已也要选一个学习成本低，文档和社区资源丰富的。我们团队的很多加班就是因为选择了一个我们不熟悉又没什么文档和社区资源的CMS系统……所以技术选型一定要根据团队成员已有的技术来考虑。&lt;/li&gt;
&lt;li&gt;前期做好充足的技术调研。项目风险的最大爆发点，就在于未知，只有前期花功夫做好了技术调研，才可以控制好项目风险，做到心中有底，特别在有其他系统需要集成或者有老系统需要改造的情况下，更要了解好已有的系统接口和数据库是否可以满足新的业务需求。&lt;/li&gt;
&lt;li&gt;在需求上与客户达成基本一致。我们所有的技术选型都是基于需求的，如果基本需求没有理解好，或者没有与客户达成一致，那么中后期很有能有整个技术架构无法满足业务需求的情况，这个时候如果要推翻已有架构重新开发，那将是一个巨大的风险，甚至可能项目失败。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在做技术选型的过程中，团队可以快速开发一些demo让客户试用，来验证我们选择的技术是否可以满足客户的需求，同时验证一些技术难点是否可以解决，还可以让团队成员先预热一下。&lt;/p&gt;

&lt;h3&gt;前端框架的选型&lt;/h3&gt;

&lt;p&gt;这个项目的主要需求包括三部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;由于是官网网站，所以肯定会有针对新闻公告、活动促销、业务介绍等的内容管理和发布系统。&lt;/li&gt;
&lt;li&gt;客户希望在官方网站上，提供几个核心业务的自助功能，方便用户也降低自己人力的成本。&lt;/li&gt;
&lt;li&gt;兼容性需求：完全兼容IE8及以上的IE浏览器，和Chrome, Firefox, Safari等现代浏览器，对于IE6, IE7可以样式不一致，但是功能要可用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由此可以引申出下面的一些前端技术要求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网站的自助查询部分要求可以根据API返回的数据，动态渲染页面。&lt;/li&gt;
&lt;li&gt;前端框架不能够太新，否则会导致IE6, IE7上功能不可用。&lt;/li&gt;
&lt;li&gt;由于是官方网站，对于网站的样式有很高的要求，所以样式代码肯定会很多，需要有一个很好的管理方式。&lt;/li&gt;
&lt;li&gt;网站中可能会有很多重复的部分，需要我们选择的框架可以方便的写可复用的组件。&lt;/li&gt;
&lt;li&gt;官网网站的访问量很大，同时国内的带宽有限，需要选择体积较小的框架。&lt;/li&gt;
&lt;li&gt;出于ThoughtWorks的传统，我们需要选择一个利于自动化和测试的框架。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据上面的要求，我们确定我们需要以下类型的架构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JS MVC Framework: 负责与API交互，并动态选软页面。&lt;/li&gt;
&lt;li&gt;CSS Framework: 帮助我们快速搭建网站，并且很好的管理CSS代码。&lt;/li&gt;
&lt;li&gt;Automation Framework: 自动化的打包、压缩代码，启动开发环境，运行测试。&lt;/li&gt;
&lt;li&gt;Dependency Manager: 管理各种依赖，包括我们自身代码的以及第三方库的。&lt;/li&gt;
&lt;li&gt;Test Framework: 可以与Automation Framework方便的集成，运行我们的测试代码，并且可以方便的mock API。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;JS MVC Framework&lt;/h4&gt;

&lt;p&gt;我们考虑的选项有：&lt;a href="http://backbonejs.org/"&gt;Backbone.js&lt;/a&gt;，&lt;a href="http://angularjs.org/"&gt;Angular.js&lt;/a&gt;。其他还有更多的选项可以在&lt;a href="http://todomvc.com/"&gt;TodoMVC&lt;/a&gt;找到，由于其他的框架都不是团队所熟悉的，所以我们不予考虑。&lt;/p&gt;

&lt;p&gt;Backbone.js的特点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非常小巧，加上&lt;a href="http://underscorejs.org/"&gt;Underscore.js&lt;/a&gt;也才11.5kb。&lt;/li&gt;
&lt;li&gt;学习曲线平滑，所有的代码加注释也只有1000多行，通过他自己的&lt;a href="http://backbonejs.org/docs/backbone.html"&gt;Annotated Source&lt;/a&gt;，半天就能看完所有的代码。他本身的概念也没有那么多，掌握好Event, Model, Collection, View四个概念就够了。&lt;/li&gt;
&lt;li&gt;兼容性好，由于没有太多特殊的功能，所以他可以兼容更多的浏览器。&lt;/li&gt;
&lt;li&gt;项目越大越复杂会导致代码越难维护。由于Backbone.js中的View做了非常多的事情，包括绑定数据、绑定交互事件、与Model交互、管理sub view等等，所以往往view会越来越膨胀；同时因为Backbone.js的简单，意味着我们自己要写更多的代码，越大的项目中Backbone.js与Angular.js的差距越大。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Angular.js的特点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从2009年就已经诞生，发展到现在功能和社区都非常强大，已经形成了一套从开发理念、配套工具到各种第三方工具都比较完善的生态圈。&lt;/li&gt;
&lt;li&gt;由于功能强大和独特的开发理念，导致学习曲线非常陡峭。我们需要掌握他的DI, scope, directive等等各种概念，其中特别是由于自有directive导致的scope问题往往让熟手都摸不着头脑。&lt;/li&gt;
&lt;li&gt;文件比较大，minify以后还是有100多kb。&lt;/li&gt;
&lt;li&gt;基本不支持IE6, IE7.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;综上所述，Backbone.js比较适合兼容性要求比较高的中小型项目，而Angular.js比较适合全站Single Page Application的大型项目，同时兼容性要求不高。最后我们选择了Backbone.js。&lt;/p&gt;

&lt;h4&gt;CSS Framework&lt;/h4&gt;

&lt;p&gt;我们考虑的选项有：&lt;a href="http://sass-lang.com/"&gt;SASS&lt;/a&gt;，&lt;a href="http://lesscss.org/"&gt;LESS&lt;/a&gt;。其他的选择还有&lt;a href="http://learnboost.github.io/stylus/"&gt;Stylus&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;总的来说这两者本身没有太大区别，虽然LESS号称更加简单，但SASS也没有复杂难用多少，而LESS也具有了所有的关键功能。重要的区别在于SASS有Compass这个工具，可以解决不同浏览器的某些CSS写法不同的问题，可以帮助我们生成Sprites（可以参考我的&lt;a href="http://www.zation.me/2013/01/13/sass_compass_best_practices_3.html"&gt;这篇博客&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;由于SASS有更好的社区支持（&lt;a href="http://compass-style.org/"&gt;Compass&lt;/a&gt;, &lt;a href="https://github.com/owainlewis/gravity"&gt;Gravity&lt;/a&gt;, and &lt;a href="]"&gt;Susy&lt;/a&gt;），所以我们最后选择了SASS。&lt;/p&gt;

&lt;h4&gt;Automation&lt;/h4&gt;

&lt;p&gt;这里我们只有一个考虑，就是Grunt，当然还有其他选择，比如&lt;a href="http://gulpjs.com/"&gt;Gulp&lt;/a&gt;，但是由于Yeoman的主要generator还是使用的Grunt，并且使用新工具也有一定的熟悉时间和风险，所以我们最终还是选择了Yeoman + Grunt。&lt;/p&gt;

&lt;h4&gt;Dependency Manager&lt;/h4&gt;

&lt;p&gt;前端第三方插件的管理工具现在除了&lt;a href="http://bower.io/"&gt;bower&lt;/a&gt;，我不知道有其他的选择了。&lt;/p&gt;

&lt;p&gt;对于自身代码的依赖管理工具，并不是选择哪一个框架的问题，基本都是选择&lt;a href="http://requirejs.org/"&gt;require.js&lt;/a&gt;，问题在于要不要用这个工具。由于Backbone.js并没有提供模块化和依赖管理的功能，所以我们还是尝试了使用require.js来管理自身依赖，但是实际情况是我们只把require.js用作一个打包代码的工具，而不是加载代码的工具，同时在修改文件名称或路径的时候非常麻烦，因为require.js的依赖是由文件的路径和名称确定的。解决这个问题的方式是使用模块名来定义模块，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Explicitly defines the &amp;quot;foo/title&amp;quot; module:
define(&amp;quot;foo/title&amp;quot;,
    [&amp;quot;my/cart&amp;quot;, &amp;quot;my/inventory&amp;quot;],
    function(cart, inventory) {
        //Define foo/title object in here.
   }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样不管如何移动或重命名文件都不会有问题了。&lt;/p&gt;

&lt;h4&gt;Test Framework&lt;/h4&gt;

&lt;p&gt;我们考虑的选项有：&lt;a href="http://jasmine.github.io/"&gt;Jasmine&lt;/a&gt;，&lt;a href="http://visionmedia.github.io/mocha/"&gt;Mocha&lt;/a&gt; + &lt;a href="http://chaijs.com/"&gt;Chai&lt;/a&gt; + &lt;a href="http://sinonjs.org/"&gt;Sinon&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;关于Jasmine和Mocha的优缺点，曾经在Yeoman从Jasmine切换到Mocha的时候引发过&lt;a href="https://github.com/yeoman/yeoman/issues/117"&gt;讨论&lt;/a&gt;，包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;String diffs&lt;/li&gt;
&lt;li&gt;Test coverage reporting&lt;/li&gt;
&lt;li&gt;Simpler async test interface&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以最终我们的选择是Mocha + Chai + Sinon。&lt;/p&gt;

&lt;p&gt;在这些选型完成以后，我们还遇到了不少问题，有一些解决了，成为了项目的亮点，有一些没有解决，就变成了项目天坑的一部分。后面我们会逐个介绍我们遇到的问题和优化，希望对别人能够有所帮助。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>打造离线使用的Mobile Web App</title>
    <link rel="alternate" href="/2013/05/28/build_offline_mobile_web_app.html"/>
    <id>/2013/05/28/build_offline_mobile_web_app.html</id>
    <published>2013-05-28T06:28:00Z</published>
    <updated>2013-05-28T06:28:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img title="HTML5" alt="HTML5" src="/images/appcache/html5.png?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;最近公司举办技术大赛，我和同事一起制作了一个叫做&lt;a href="http://10khours.me"&gt;10K Hours&lt;/a&gt;的Mobile Web App，可以帮助你通过一万小时的努力，成为某个领域的专家。正好前段时间翻译了一本书&lt;a href="http://book.douban.com/subject/10580867/"&gt;《HTML5 Mobile Development Cookbook》&lt;/a&gt;，中文译本&lt;a href="http://book.douban.com/subject/24706036/"&gt;在此&lt;/a&gt;。其中讲到了不少移动端Web开发的Best Practices，正好就用到了10K Hours这个应用上。其中我觉得非常有用但是又让人头痛的一个功能就是AppCache：它可以让用户在访问一次网页以后，下次再来时不能访问网络的情况下，也可以使用这个Web App；但是当页面资源被缓存以后，非常难去更新它们⋯⋯下面就是App Cache的详细介绍和使用技巧&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;img title="HTML5" alt="HTML5" src="/images/appcache/html5.png?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;最近公司举办技术大赛，我和同事一起制作了一个叫做&lt;a href="http://10khours.me"&gt;10K Hours&lt;/a&gt;的Mobile Web App，可以帮助你通过一万小时的努力，成为某个领域的专家。正好前段时间翻译了一本书&lt;a href="http://book.douban.com/subject/10580867/"&gt;《HTML5 Mobile Development Cookbook》&lt;/a&gt;，中文译本&lt;a href="http://book.douban.com/subject/24706036/"&gt;在此&lt;/a&gt;。其中讲到了不少移动端Web开发的Best Practices，正好就用到了10K Hours这个应用上。其中我觉得非常有用但是又让人头痛的一个功能就是AppCache：它可以让用户在访问一次网页以后，下次再来时不能访问网络的情况下，也可以使用这个Web App；但是当页面资源被缓存以后，非常难去更新它们⋯⋯下面就是App Cache的详细介绍和使用技巧：&lt;/p&gt;

&lt;h3&gt;什么是AppCache&lt;/h3&gt;

&lt;p&gt;下面是来自&lt;a href="http://www.w3.org/TR/2011/WD-html5-20110525/offline.html"&gt;W3C&lt;/a&gt;的解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In order to enable users to continue interacting with Web applications and documents even when their network connection is unavailable — for instance, because they are traveling outside of their ISP&amp;#39;s coverage area — authors can provide a manifest which lists the files that are needed for the Web application to work offline and which causes the user&amp;#39;s browser to keep a copy of the files for use offline.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说就是可以让开发者在网络出问题的情况下，可以部分或全部访问网站的静态资源。&lt;/p&gt;

&lt;p&gt;可能有些朋友会疑惑AppCache与浏览器自动缓存和localStorage的区别，这里我简单讲一下：在默认设置下，浏览器会根据request header自动缓存静态文件，但是在请求该文件时还是会发出http request，而一旦被AppCache缓存住的文件就不会发送http request，除非人工触发缓存更新；localStorage也是一种缓存，但是它缓存的是数据，而AppCache缓存的是文件。&lt;/p&gt;

&lt;h3&gt;如何使用AppCache&lt;/h3&gt;

&lt;p&gt;要引入AppCache一般有三个步骤：&lt;/p&gt;

&lt;h4&gt;1. 声明manifest文件&lt;/h4&gt;

&lt;p&gt;manifest可以告诉浏览器网站的cache行为，下面是一个完整的manifest文件示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CACHE MANIFEST
# Time: Wed May 22 2013 17:07:07 GMT+0800 (CST)

CACHE:
index.html
stylesheet.css
images/logo.png
scripts/main.js

NETWORK:
myApp/api
http://api.twitter.com

FALLBACK:
images/large/ images/offline.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CACHE MANIFEST&lt;/code&gt;表明该文件用于AppCache的配置，必须放在第一行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;# Time: Wed May 22 2013 17:07:07 GMT+0800 (CST)&lt;/code&gt;是一个时间戳，用于触发缓存文件的更新，这个会在后面详细讲到。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CACHE&lt;/code&gt;指定需要被缓存的文件。这些文件会被缓存到AppCache中，以后这些文件都会从AppCache中加载。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NETWORK&lt;/code&gt;指定不需要被缓存的文件。这些文件不会被缓存到AppCache中，一般用于一些动态的页面或数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：一些浏览器会给缓存容量加入上限，比如Chrome浏览器就是使用一个共有的缓存池，如果超出上限，以前缓存的文件有可能会被清除掉。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FALLBACK&lt;/code&gt;指定当网络不可用时的替代文件，这些文件在网络可用时不会从AppCache中读取，只有当网络不可用时才会从AppCache中读取。示例中指定当&lt;code&gt;images/large/&lt;/code&gt;中的任意文件无法访问时，都从AppCache中读取&lt;code&gt;images/offline.jpg&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;我们一般使用&lt;code&gt;.appcache&lt;/code&gt;作为manifest文件的后缀，这个是WHATWG的建议，同时也获得了更多浏览器的支持。&lt;/p&gt;

&lt;h4&gt;2. 在页面中引入manifest文件&lt;/h4&gt;

&lt;p&gt;引入manifest文件需要在html标签中加入manifest属性，其值为manifest文件地址，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html manifest=&amp;quot;example.appcache&amp;quot;&amp;gt;
  ...
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你需要在每个用到AppCache的页面都加入manifest属性，除非该页面就在缓存列表中，而拥有manifest属性的页面会自动被缓存住，不需要再加入缓存列表了。&lt;/p&gt;

&lt;h4&gt;3. 修改服务器端的mime-type&lt;/h4&gt;

&lt;p&gt;为了让服务器端可以正确的处理manifest文件，需要在mine-type中加入&lt;code&gt;text/cache-manifest&lt;/code&gt;。比如在Apache服务器中，可以添加以下行到配置文件中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AddType text/cache-manifest .appcache
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;更新缓存&lt;/h3&gt;

&lt;p&gt;完成manifest文件的配置以后，你会发现你的页面加载速度暴增，可以算是秒载，但是你也会悲催的发现，任何文件的修改将不会被反应到页面上，那么当我们有文件修改的时候应该怎么办呢？&lt;/p&gt;

&lt;h4&gt;修改manifest文件&lt;/h4&gt;

&lt;p&gt;有两种情况可以导致缓存更新：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用户清除缓存数据。&lt;/li&gt;
&lt;li&gt;manifest文件修改。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以我们要更新缓存，其实只有一个办法，那就是修改manifest文件。这个时候我们就可以看到在上个例子中那个被注释掉的时间戳（&lt;code&gt;# Time: Wed May 22 2013 17:07:07 GMT+0800 (CST)&lt;/code&gt;）的作用了，每当任意一个被缓存的文件修改后，我们都应该修改manifest文件的时间戳，让浏览器知道有文件更改，应该更新缓存。&lt;/p&gt;

&lt;p&gt;当浏览器检测到manifest文件更改以后，它会发起请求更新所有被缓存的文件，但是这时候还不会马上更新到页面中，还需要用户再次刷新页面，才能看到新的内容。也就是说，当我们有文件修改以后，需要用户刷新两次才能看到新的内容，这个对于用户来说是很奇怪的体验。这个时候我们可以利用AppCache提供的一些接口来解决这个问题。&lt;/p&gt;

&lt;h4&gt;AppCache接口&lt;/h4&gt;

&lt;p&gt;AppCache提供了以下的事件接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;checking&lt;/code&gt;：客户端正在检查manifest文件的更新，或者尝试下载manifest文件时触发。注意：这个事件总是首先触发的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noupdate&lt;/code&gt;：客户端检查manifest文件，并且manifest文件没有更新时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;downloading&lt;/code&gt;：客户端发现manifest文件需要更新并开始更新，或者开始下载manifest中列举的缓存文件时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;progress&lt;/code&gt;：客户端下载manifest中列巨额的缓存文件时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cached&lt;/code&gt;：manifest中的文件被下载，并且被缓存以后触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;updateready&lt;/code&gt;：当新的缓存文件下载完成后触发，可以利用swapCache()来应用新的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中最重要的就是&lt;code&gt;updateready&lt;/code&gt;这个事件，我们可以利用JavaScript绑定这个事件，在缓存更新的时候自动刷新来应用这些更新，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Check if a new cache is available on page load.
window.addEventListener(&amp;#39;load&amp;#39;, function(e) {

  window.applicationCache.addEventListener(&amp;#39;updateready&amp;#39;, function(e) {
    if (window.applicationCache.status == window.applicationCache.UPDATEREADY) {
      // Browser downloaded a new app cache.
      // Swap it in and reload the page to get the new hotness.
      window.applicationCache.swapCache();
      if (confirm(&amp;#39;A new version of this site is available. Load it?&amp;#39;)) {
        window.location.reload();
      }
    } else {
      // Manifest didn&amp;#39;t changed. Nothing new to server.
    }
  }, false);

}, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;AppCache的Debug&lt;/h3&gt;

&lt;p&gt;当我们在本地调试的时候，我们如何知道AppCache是否起效果，并缓存了哪些文件呢？Chrome的开发者工具提供了这些信息，打开开发者工具，在Resource =&amp;gt; Application Cache中就可以看到缓存了哪些文件，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img title="AppCache Debug" alt="AppCache Debug" src="/images/appcache/debug.png?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;但是在这里不能对Cache进行删除操作，也不能看到其他网站的Cache。如果想看到所有网站的AppCache信息，并且删除其中某一个的话，可以进入&lt;a href="chrome://appcache-internals/"&gt;chrome://appcache-internals/&lt;/a&gt;，这个管理页面会列出所有浏览器中的AppCache信息，包括manifest地址、缓存大小、更新时间、创建时间等等⋯⋯&lt;/p&gt;

&lt;h3&gt;延伸&lt;/h3&gt;

&lt;p&gt;到这里我们就已经讲解了关于AppCache的基础知识，这里还有一些推荐阅读的资料，同时也是我的参考资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.w3.org/TR/2011/WD-html5-20110525/offline.html"&gt;W3C关于AppCache的标准文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.html5rocks.com/en/tutorials/appcache/beginner/"&gt;A Beginner&amp;#39;s Guide to Using the Application Cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.christian-heindel.de/2011/10/25/debugging-html5-offline-web-applications/"&gt;Debugging HTML5 Offline Web applications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://appcachefacts.info/"&gt;Appcache Facts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
