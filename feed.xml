<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zation's Blog</title>
  <subtitle>Coding for fun</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://zation.me/"/>
  <link href="http://zation.me/feed.xml" rel="self"/>
  <updated>2014-06-09T15:31:00Z</updated>
  <author>
    <name>Zation</name>
  </author>
  <entry>
    <title>国内项目天坑记（二）——Gruntfile的模块化</title>
    <link rel="alternate" href="/2014/06/09/grunt_config_as_modules.html"/>
    <id>/2014/06/09/grunt_config_as_modules.html</id>
    <published>2014-06-09T15:31:00Z</published>
    <updated>2014-06-09T15:31:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;在大型项目中用过Grunt的都知道，当自动化的配置和task多了一个，一个Gruntfile.js文件可能有好几百行，这样维护非常困难，于是对Gruntfile的模块化势在必行。感谢&lt;a href="http://zhuanlan.zhihu.com/tla42"&gt;墨磊&lt;/a&gt;同学帮助我们做了模块化！以下内容都是他的实践。&lt;/p&gt;

&lt;p&gt;本质上Gruntfile.js就是一个node.js代码文件，所以我们可以很方便的用&lt;a href="http://www.commonjs.org"&gt;CommonJS&lt;/a&gt;的规范将Gruntfile.js模块化。下面我们首先来看看模块化以后的grunt目录结构：&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;在大型项目中用过Grunt的都知道，当自动化的配置和task多了一个，一个Gruntfile.js文件可能有好几百行，这样维护非常困难，于是对Gruntfile的模块化势在必行。感谢&lt;a href="http://zhuanlan.zhihu.com/tla42"&gt;墨磊&lt;/a&gt;同学帮助我们做了模块化！以下内容都是他的实践。&lt;/p&gt;

&lt;p&gt;本质上Gruntfile.js就是一个node.js代码文件，所以我们可以很方便的用&lt;a href="http://www.commonjs.org"&gt;CommonJS&lt;/a&gt;的规范将Gruntfile.js模块化。下面我们首先来看看模块化以后的grunt目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Gruntfile.js
grunt/
    compile/
        compass.js
        concat.js
        uglify.js
        ...
    dev/
        jshint.js
        connect.js
        ...
    config.js
    tasks.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里要提一下grunt模块划分，一般是根据task的不同来划分的。而&lt;a href="http://gulpjs.com/"&gt;gulp&lt;/a&gt;是根据处理的文件类型的不同来划分的。&lt;/p&gt;

&lt;p&gt;Gruntfile.js所做的事情就很简单了，只是加载tasks.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;#39;use strict&amp;#39;;

module.exports = function (grunt) {
    // load tasks
    require(&amp;#39;./grunt/tasks.js&amp;#39;)(grunt);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tasks.js负责加载和注册所有的tasks和config.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function (grunt) {

    require(&amp;#39;./config.js&amp;#39;)(grunt);

    grunt.loadTasks(&amp;#39;./grunt/compile&amp;#39;);
    grunt.loadTasks(&amp;#39;./grunt/dev&amp;#39;);

    grunt.registerTask(&amp;#39;some tasks&amp;#39;, function () {
        //...
    });

    return grunt;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这里&lt;code&gt;grunt.loadTasks()&lt;/code&gt;方法的路径是相对于Gruntfile.js的。&lt;/p&gt;

&lt;p&gt;config.js负责配置项目相关的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function (grunt) {
    grunt.initConfig({
        // configurable paths
        server: {
            hostname: &amp;#39;0.0.0.0&amp;#39;,
            hostport: &amp;#39;9000&amp;#39;
        },
        testServer: {
            hostname: &amp;#39;localhost&amp;#39;,
            hostport: &amp;#39;9001&amp;#39;
        },
        yeoman: {
            app: &amp;#39;app&amp;#39;,
            dist: &amp;#39;dist&amp;#39;,
            test: &amp;#39;test&amp;#39;,
            tmp: &amp;#39;.tmp&amp;#39;
        }
    });

    return grunt;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;compile文件夹下的tasks是在build production package的时候用到的，dev文件夹下的tasks是在开发环境中用到的，这里也可以根据项目的实际情况进行分类。&lt;/p&gt;

&lt;p&gt;这里我认为还可以做优化的地方在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用.json配置文件代替.js配置文件，并且预先设订好对于不同环境的配置文件，例如：config.json.development, config.json.production, config.json.staging, config.json.test... 不同的环境中就使用不同的配置文件，这样让所有的配置文件都可以做版本管理，而且也更加统一。&lt;/li&gt;
&lt;li&gt;使用npm将这些配置代码都打包，放到另一个独立的github repo中，这样可以简化项目结构和代码，同时也利于这些代码在其他项目中的共用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些优化我已经在新的项目中进行过尝试了，效果挺不错的，后面会写一篇更加详细的文章来进行介绍。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>国内项目天坑记（一）——大型官方网站中的前端选型</title>
    <link rel="alternate" href="/2014/06/05/frontend_architecture_in_a_large_corp_portal_site.html"/>
    <id>/2014/06/05/frontend_architecture_in_a_large_corp_portal_site.html</id>
    <published>2014-06-05T13:08:00Z</published>
    <updated>2014-06-05T13:08:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img title="Architecture" alt="Architecture" src="/images/architecture.jpg?1402338328" /&gt;&lt;/p&gt;

&lt;p&gt;一年多的时间没有写博客了，这段时间一直在加班加点的赶一个国内官方网站项目，基本12*6的工作时间让博客荒废了这么久，现在终于有些时间总结整理一下这个项目中的一些坑和经验。之所以叫做天坑记而不是填坑记，是因为该坑连绵不绝，是一个堪称有生之年的坑……&lt;/p&gt;

&lt;p&gt;项目开始的初期，面临着很多许多技术选型，选的好可以让后面的开发事半功倍，选的不好……就只能自己埋的坑自己填了。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;img title="Architecture" alt="Architecture" src="/images/architecture.jpg?1402338328" /&gt;&lt;/p&gt;

&lt;p&gt;一年多的时间没有写博客了，这段时间一直在加班加点的赶一个国内官方网站项目，基本12*6的工作时间让博客荒废了这么久，现在终于有些时间总结整理一下这个项目中的一些坑和经验。之所以叫做天坑记而不是填坑记，是因为该坑连绵不绝，是一个堪称有生之年的坑……&lt;/p&gt;

&lt;p&gt;项目开始的初期，面临着很多许多技术选型，选的好可以让后面的开发事半功倍，选的不好……就只能自己埋的坑自己填了。&lt;/p&gt;

&lt;h3&gt;选型的注意事项&lt;/h3&gt;

&lt;p&gt;现在回过头来看，做技术选型有下面几个要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不要选择团队不熟悉的技术。即使一些新的技术看起来非常诱人又具有挑战性，除非团队中有牛人签了卖身契和军令状保证可以搞定因为新技术所产生的问题。实在逼不得已也要选一个学习成本低，文档和社区资源丰富的。我们团队的很多加班就是因为选择了一个我们不熟悉又没什么文档和社区资源的CMS系统……所以技术选型一定要根据团队成员已有的技术来考虑。&lt;/li&gt;
&lt;li&gt;前期做好充足的技术调研。项目风险的最大爆发点，就在于未知，只有前期花功夫做好了技术调研，才可以控制好项目风险，做到心中有底，特别在有其他系统需要集成或者有老系统需要改造的情况下，更要了解好已有的系统接口和数据库是否可以满足新的业务需求。&lt;/li&gt;
&lt;li&gt;在需求上与客户达成基本一致。我们所有的技术选型都是基于需求的，如果基本需求没有理解好，或者没有与客户达成一致，那么中后期很有能有整个技术架构无法满足业务需求的情况，这个时候如果要推翻已有架构重新开发，那将是一个巨大的风险，甚至可能项目失败。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在做技术选型的过程中，团队可以快速开发一些demo让客户试用，来验证我们选择的技术是否可以满足客户的需求，同时验证一些技术难点是否可以解决，还可以让团队成员先预热一下。&lt;/p&gt;

&lt;h3&gt;前端框架的选型&lt;/h3&gt;

&lt;p&gt;这个项目的主要需求包括三部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;由于是官网网站，所以肯定会有针对新闻公告、活动促销、业务介绍等的内容管理和发布系统。&lt;/li&gt;
&lt;li&gt;客户希望在官方网站上，提供几个核心业务的自助功能，方便用户也降低自己人力的成本。&lt;/li&gt;
&lt;li&gt;兼容性需求：完全兼容IE8及以上的IE浏览器，和Chrome, Firefox, Safari等现代浏览器，对于IE6, IE7可以样式不一致，但是功能要可用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由此可以引申出下面的一些前端技术要求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网站的自助查询部分要求可以根据API返回的数据，动态渲染页面。&lt;/li&gt;
&lt;li&gt;前端框架不能够太新，否则会导致IE6, IE7上功能不可用。&lt;/li&gt;
&lt;li&gt;由于是官方网站，对于网站的样式有很高的要求，所以样式代码肯定会很多，需要有一个很好的管理方式。&lt;/li&gt;
&lt;li&gt;网站中可能会有很多重复的部分，需要我们选择的框架可以方便的写可复用的组件。&lt;/li&gt;
&lt;li&gt;官网网站的访问量很大，同时国内的带宽有限，需要选择体积较小的框架。&lt;/li&gt;
&lt;li&gt;出于ThoughtWorks的传统，我们需要选择一个利于自动化和测试的框架。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据上面的要求，我们确定我们需要以下类型的架构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JS MVC Framework: 负责与API交互，并动态选软页面。&lt;/li&gt;
&lt;li&gt;CSS Framework: 帮助我们快速搭建网站，并且很好的管理CSS代码。&lt;/li&gt;
&lt;li&gt;Automation Framework: 自动化的打包、压缩代码，启动开发环境，运行测试。&lt;/li&gt;
&lt;li&gt;Dependency Manager: 管理各种依赖，包括我们自身代码的以及第三方库的。&lt;/li&gt;
&lt;li&gt;Test Framework: 可以与Automation Framework方便的集成，运行我们的测试代码，并且可以方便的mock API。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;JS MVC Framework&lt;/h4&gt;

&lt;p&gt;我们考虑的选项有：&lt;a href="http://backbonejs.org/"&gt;Backbone.js&lt;/a&gt;，&lt;a href="http://angularjs.org/"&gt;Angular.js&lt;/a&gt;。其他还有更多的选项可以在&lt;a href="http://todomvc.com/"&gt;TodoMVC&lt;/a&gt;找到，由于其他的框架都不是团队所熟悉的，所以我们不予考虑。&lt;/p&gt;

&lt;p&gt;Backbone.js的特点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非常小巧，加上&lt;a href="http://underscorejs.org/"&gt;Underscore.js&lt;/a&gt;也才11.5kb。&lt;/li&gt;
&lt;li&gt;学习曲线平滑，所有的代码加注释也只有1000多行，通过他自己的&lt;a href="http://backbonejs.org/docs/backbone.html"&gt;Annotated Source&lt;/a&gt;，半天就能看完所有的代码。他本身的概念也没有那么多，掌握好Event, Model, Collection, View四个概念就够了。&lt;/li&gt;
&lt;li&gt;兼容性好，由于没有太多特殊的功能，所以他可以兼容更多的浏览器。&lt;/li&gt;
&lt;li&gt;项目越大越复杂会导致代码越难维护。由于Backbone.js中的View做了非常多的事情，包括绑定数据、绑定交互事件、与Model交互、管理sub view等等，所以往往view会越来越膨胀；同时因为Backbone.js的简单，意味着我们自己要写更多的代码，越大的项目中Backbone.js与Angular.js的差距越大。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Angular.js的特点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从2009年就已经诞生，发展到现在功能和社区都非常强大，已经形成了一套从开发理念、配套工具到各种第三方工具都比较完善的生态圈。&lt;/li&gt;
&lt;li&gt;由于功能强大和独特的开发理念，导致学习曲线非常陡峭。我们需要掌握他的DI, scope, directive等等各种概念，其中特别是由于自有directive导致的scope问题往往让熟手都摸不着头脑。&lt;/li&gt;
&lt;li&gt;文件比较大，minify以后还是有100多kb。&lt;/li&gt;
&lt;li&gt;基本不支持IE6, IE7.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;综上所述，Backbone.js比较适合兼容性要求比较高的中小型项目，而Angular.js比较适合全站Single Page Application的大型项目，同时兼容性要求不高。最后我们选择了Backbone.js。&lt;/p&gt;

&lt;h4&gt;CSS Framework&lt;/h4&gt;

&lt;p&gt;我们考虑的选项有：&lt;a href="http://sass-lang.com/"&gt;SASS&lt;/a&gt;，&lt;a href="http://lesscss.org/"&gt;LESS&lt;/a&gt;。其他的选择还有&lt;a href="http://learnboost.github.io/stylus/"&gt;Stylus&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;总的来说这两者本身没有太大区别，虽然LESS号称更加简单，但SASS也没有复杂难用多少，而LESS也具有了所有的关键功能。重要的区别在于SASS有Compass这个工具，可以解决不同浏览器的某些CSS写法不同的问题，可以帮助我们生成Sprites（可以参考我的&lt;a href="http://www.zation.me/2013/01/13/sass_compass_best_practices_3.html"&gt;这篇博客&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;由于SASS有更好的社区支持（&lt;a href="http://compass-style.org/"&gt;Compass&lt;/a&gt;, &lt;a href="https://github.com/owainlewis/gravity"&gt;Gravity&lt;/a&gt;, and &lt;a href="]"&gt;Susy&lt;/a&gt;），所以我们最后选择了SASS。&lt;/p&gt;

&lt;h4&gt;Automation&lt;/h4&gt;

&lt;p&gt;这里我们只有一个考虑，就是Grunt，当然还有其他选择，比如&lt;a href="http://gulpjs.com/"&gt;Gulp&lt;/a&gt;，但是由于Yeoman的主要generator还是使用的Grunt，并且使用新工具也有一定的熟悉时间和风险，所以我们最终还是选择了Yeoman + Grunt。&lt;/p&gt;

&lt;h4&gt;Dependency Manager&lt;/h4&gt;

&lt;p&gt;前端第三方插件的管理工具现在除了&lt;a href="http://bower.io/"&gt;bower&lt;/a&gt;，我不知道有其他的选择了。&lt;/p&gt;

&lt;p&gt;对于自身代码的依赖管理工具，并不是选择哪一个框架的问题，基本都是选择&lt;a href="http://requirejs.org/"&gt;require.js&lt;/a&gt;，问题在于要不要用这个工具。由于Backbone.js并没有提供模块化和依赖管理的功能，所以我们还是尝试了使用require.js来管理自身依赖，但是实际情况是我们只把require.js用作一个打包代码的工具，而不是加载代码的工具，同时在修改文件名称或路径的时候非常麻烦，因为require.js的依赖是由文件的路径和名称确定的。解决这个问题的方式是使用模块名来定义模块，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Explicitly defines the &amp;quot;foo/title&amp;quot; module:
define(&amp;quot;foo/title&amp;quot;,
    [&amp;quot;my/cart&amp;quot;, &amp;quot;my/inventory&amp;quot;],
    function(cart, inventory) {
        //Define foo/title object in here.
   }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样不管如何移动或重命名文件都不会有问题了。&lt;/p&gt;

&lt;h4&gt;Test Framework&lt;/h4&gt;

&lt;p&gt;我们考虑的选项有：&lt;a href="http://jasmine.github.io/"&gt;Jasmine&lt;/a&gt;，&lt;a href="http://visionmedia.github.io/mocha/"&gt;Mocha&lt;/a&gt; + &lt;a href="http://chaijs.com/"&gt;Chai&lt;/a&gt; + &lt;a href="http://sinonjs.org/"&gt;Sinon&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;关于Jasmine和Mocha的优缺点，曾经在Yeoman从Jasmine切换到Mocha的时候引发过&lt;a href="https://github.com/yeoman/yeoman/issues/117"&gt;讨论&lt;/a&gt;，包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;String diffs&lt;/li&gt;
&lt;li&gt;Test coverage reporting&lt;/li&gt;
&lt;li&gt;Simpler async test interface&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以最终我们的选择是Mocha + Chai + Sinon。&lt;/p&gt;

&lt;p&gt;在这些选型完成以后，我们还遇到了不少问题，有一些解决了，成为了项目的亮点，有一些没有解决，就变成了项目天坑的一部分。后面我们会逐个介绍我们遇到的问题和优化，希望对别人能够有所帮助。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>打造离线使用的Mobile Web App</title>
    <link rel="alternate" href="/2013/05/28/build_offline_mobile_web_app.html"/>
    <id>/2013/05/28/build_offline_mobile_web_app.html</id>
    <published>2013-05-28T06:28:00Z</published>
    <updated>2013-05-28T06:28:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img title="HTML5" alt="HTML5" src="/images/appcache/html5.png?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;最近公司举办技术大赛，我和同事一起制作了一个叫做&lt;a href="http://10khours.me"&gt;10K Hours&lt;/a&gt;的Mobile Web App，可以帮助你通过一万小时的努力，成为某个领域的专家。正好前段时间翻译了一本书&lt;a href="http://book.douban.com/subject/10580867/"&gt;《HTML5 Mobile Development Cookbook》&lt;/a&gt;，中文译本&lt;a href="http://book.douban.com/subject/24706036/"&gt;在此&lt;/a&gt;。其中讲到了不少移动端Web开发的Best Practices，正好就用到了10K Hours这个应用上。其中我觉得非常有用但是又让人头痛的一个功能就是AppCache：它可以让用户在访问一次网页以后，下次再来时不能访问网络的情况下，也可以使用这个Web App；但是当页面资源被缓存以后，非常难去更新它们⋯⋯下面就是App Cache的详细介绍和使用技巧&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;img title="HTML5" alt="HTML5" src="/images/appcache/html5.png?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;最近公司举办技术大赛，我和同事一起制作了一个叫做&lt;a href="http://10khours.me"&gt;10K Hours&lt;/a&gt;的Mobile Web App，可以帮助你通过一万小时的努力，成为某个领域的专家。正好前段时间翻译了一本书&lt;a href="http://book.douban.com/subject/10580867/"&gt;《HTML5 Mobile Development Cookbook》&lt;/a&gt;，中文译本&lt;a href="http://book.douban.com/subject/24706036/"&gt;在此&lt;/a&gt;。其中讲到了不少移动端Web开发的Best Practices，正好就用到了10K Hours这个应用上。其中我觉得非常有用但是又让人头痛的一个功能就是AppCache：它可以让用户在访问一次网页以后，下次再来时不能访问网络的情况下，也可以使用这个Web App；但是当页面资源被缓存以后，非常难去更新它们⋯⋯下面就是App Cache的详细介绍和使用技巧：&lt;/p&gt;

&lt;h3&gt;什么是AppCache&lt;/h3&gt;

&lt;p&gt;下面是来自&lt;a href="http://www.w3.org/TR/2011/WD-html5-20110525/offline.html"&gt;W3C&lt;/a&gt;的解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In order to enable users to continue interacting with Web applications and documents even when their network connection is unavailable — for instance, because they are traveling outside of their ISP&amp;#39;s coverage area — authors can provide a manifest which lists the files that are needed for the Web application to work offline and which causes the user&amp;#39;s browser to keep a copy of the files for use offline.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说就是可以让开发者在网络出问题的情况下，可以部分或全部访问网站的静态资源。&lt;/p&gt;

&lt;p&gt;可能有些朋友会疑惑AppCache与浏览器自动缓存和localStorage的区别，这里我简单讲一下：在默认设置下，浏览器会根据request header自动缓存静态文件，但是在请求该文件时还是会发出http request，而一旦被AppCache缓存住的文件就不会发送http request，除非人工触发缓存更新；localStorage也是一种缓存，但是它缓存的是数据，而AppCache缓存的是文件。&lt;/p&gt;

&lt;h3&gt;如何使用AppCache&lt;/h3&gt;

&lt;p&gt;要引入AppCache一般有三个步骤：&lt;/p&gt;

&lt;h4&gt;1. 声明manifest文件&lt;/h4&gt;

&lt;p&gt;manifest可以告诉浏览器网站的cache行为，下面是一个完整的manifest文件示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CACHE MANIFEST
# Time: Wed May 22 2013 17:07:07 GMT+0800 (CST)

CACHE:
index.html
stylesheet.css
images/logo.png
scripts/main.js

NETWORK:
myApp/api
http://api.twitter.com

FALLBACK:
images/large/ images/offline.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CACHE MANIFEST&lt;/code&gt;表明该文件用于AppCache的配置，必须放在第一行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;# Time: Wed May 22 2013 17:07:07 GMT+0800 (CST)&lt;/code&gt;是一个时间戳，用于触发缓存文件的更新，这个会在后面详细讲到。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CACHE&lt;/code&gt;指定需要被缓存的文件。这些文件会被缓存到AppCache中，以后这些文件都会从AppCache中加载。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NETWORK&lt;/code&gt;指定不需要被缓存的文件。这些文件不会被缓存到AppCache中，一般用于一些动态的页面或数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：一些浏览器会给缓存容量加入上限，比如Chrome浏览器就是使用一个共有的缓存池，如果超出上限，以前缓存的文件有可能会被清除掉。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FALLBACK&lt;/code&gt;指定当网络不可用时的替代文件，这些文件在网络可用时不会从AppCache中读取，只有当网络不可用时才会从AppCache中读取。示例中指定当&lt;code&gt;images/large/&lt;/code&gt;中的任意文件无法访问时，都从AppCache中读取&lt;code&gt;images/offline.jpg&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;我们一般使用&lt;code&gt;.appcache&lt;/code&gt;作为manifest文件的后缀，这个是WHATWG的建议，同时也获得了更多浏览器的支持。&lt;/p&gt;

&lt;h4&gt;2. 在页面中引入manifest文件&lt;/h4&gt;

&lt;p&gt;引入manifest文件需要在html标签中加入manifest属性，其值为manifest文件地址，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html manifest=&amp;quot;example.appcache&amp;quot;&amp;gt;
  ...
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你需要在每个用到AppCache的页面都加入manifest属性，除非该页面就在缓存列表中，而拥有manifest属性的页面会自动被缓存住，不需要再加入缓存列表了。&lt;/p&gt;

&lt;h4&gt;3. 修改服务器端的mime-type&lt;/h4&gt;

&lt;p&gt;为了让服务器端可以正确的处理manifest文件，需要在mine-type中加入&lt;code&gt;text/cache-manifest&lt;/code&gt;。比如在Apache服务器中，可以添加以下行到配置文件中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AddType text/cache-manifest .appcache
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;更新缓存&lt;/h3&gt;

&lt;p&gt;完成manifest文件的配置以后，你会发现你的页面加载速度暴增，可以算是秒载，但是你也会悲催的发现，任何文件的修改将不会被反应到页面上，那么当我们有文件修改的时候应该怎么办呢？&lt;/p&gt;

&lt;h4&gt;修改manifest文件&lt;/h4&gt;

&lt;p&gt;有两种情况可以导致缓存更新：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用户清除缓存数据。&lt;/li&gt;
&lt;li&gt;manifest文件修改。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以我们要更新缓存，其实只有一个办法，那就是修改manifest文件。这个时候我们就可以看到在上个例子中那个被注释掉的时间戳（&lt;code&gt;# Time: Wed May 22 2013 17:07:07 GMT+0800 (CST)&lt;/code&gt;）的作用了，每当任意一个被缓存的文件修改后，我们都应该修改manifest文件的时间戳，让浏览器知道有文件更改，应该更新缓存。&lt;/p&gt;

&lt;p&gt;当浏览器检测到manifest文件更改以后，它会发起请求更新所有被缓存的文件，但是这时候还不会马上更新到页面中，还需要用户再次刷新页面，才能看到新的内容。也就是说，当我们有文件修改以后，需要用户刷新两次才能看到新的内容，这个对于用户来说是很奇怪的体验。这个时候我们可以利用AppCache提供的一些接口来解决这个问题。&lt;/p&gt;

&lt;h4&gt;AppCache接口&lt;/h4&gt;

&lt;p&gt;AppCache提供了以下的事件接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;checking&lt;/code&gt;：客户端正在检查manifest文件的更新，或者尝试下载manifest文件时触发。注意：这个事件总是首先触发的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noupdate&lt;/code&gt;：客户端检查manifest文件，并且manifest文件没有更新时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;downloading&lt;/code&gt;：客户端发现manifest文件需要更新并开始更新，或者开始下载manifest中列举的缓存文件时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;progress&lt;/code&gt;：客户端下载manifest中列巨额的缓存文件时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cached&lt;/code&gt;：manifest中的文件被下载，并且被缓存以后触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;updateready&lt;/code&gt;：当新的缓存文件下载完成后触发，可以利用swapCache()来应用新的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中最重要的就是&lt;code&gt;updateready&lt;/code&gt;这个事件，我们可以利用JavaScript绑定这个事件，在缓存更新的时候自动刷新来应用这些更新，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Check if a new cache is available on page load.
window.addEventListener(&amp;#39;load&amp;#39;, function(e) {

  window.applicationCache.addEventListener(&amp;#39;updateready&amp;#39;, function(e) {
    if (window.applicationCache.status == window.applicationCache.UPDATEREADY) {
      // Browser downloaded a new app cache.
      // Swap it in and reload the page to get the new hotness.
      window.applicationCache.swapCache();
      if (confirm(&amp;#39;A new version of this site is available. Load it?&amp;#39;)) {
        window.location.reload();
      }
    } else {
      // Manifest didn&amp;#39;t changed. Nothing new to server.
    }
  }, false);

}, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;AppCache的Debug&lt;/h3&gt;

&lt;p&gt;当我们在本地调试的时候，我们如何知道AppCache是否起效果，并缓存了哪些文件呢？Chrome的开发者工具提供了这些信息，打开开发者工具，在Resource =&amp;gt; Application Cache中就可以看到缓存了哪些文件，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img title="AppCache Debug" alt="AppCache Debug" src="/images/appcache/debug.png?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;但是在这里不能对Cache进行删除操作，也不能看到其他网站的Cache。如果想看到所有网站的AppCache信息，并且删除其中某一个的话，可以进入&lt;a href="chrome://appcache-internals/"&gt;chrome://appcache-internals/&lt;/a&gt;，这个管理页面会列出所有浏览器中的AppCache信息，包括manifest地址、缓存大小、更新时间、创建时间等等⋯⋯&lt;/p&gt;

&lt;h3&gt;延伸&lt;/h3&gt;

&lt;p&gt;到这里我们就已经讲解了关于AppCache的基础知识，这里还有一些推荐阅读的资料，同时也是我的参考资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.w3.org/TR/2011/WD-html5-20110525/offline.html"&gt;W3C关于AppCache的标准文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.html5rocks.com/en/tutorials/appcache/beginner/"&gt;A Beginner&amp;#39;s Guide to Using the Application Cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.christian-heindel.de/2011/10/25/debugging-html5-offline-web-applications/"&gt;Debugging HTML5 Offline Web applications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://appcachefacts.info/"&gt;Appcache Facts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>如何构建自动化的前端开发流程</title>
    <link rel="alternate" href="/2013/03/15/how-to-build-frontend-dev-env.html"/>
    <id>/2013/03/15/how-to-build-frontend-dev-env.html</id>
    <published>2013-03-15T08:21:00Z</published>
    <updated>2013-03-15T08:21:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;如今的前端开发中，已经不再只是一些简单的静态文件了，对于很多Web App来说，前端代码甚至比后端代码要更加复杂，更加难于管理，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们有许多的第三方库的依赖需要管理；&lt;/li&gt;
&lt;li&gt;我们有独立的前端测试需要自动运行；&lt;/li&gt;
&lt;li&gt;我们还有很多代码需要在发布时进行打包压缩；&lt;/li&gt;
&lt;li&gt;⋯⋯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以构建一个自动化的前端开发流程是非常必要的，但现在前端开发流程的构建是百花齐放，没有一个统一的标准，还有很多依赖于后端的架构来做前端开发管理。例如在Rails开发中，就有各种前端库的gem包。但是这种依赖于后端框架的管理方式有许多问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;许多gem包的维护者并不是前端库的维护者，所以更新不一定即时；&lt;/li&gt;
&lt;li&gt;不利于前端代码与后端代码做分离；&lt;/li&gt;
&lt;li&gt;增加了前端开发者的学习和使用成本；&lt;/li&gt;
&lt;li&gt;⋯⋯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是现在出现了一些不依赖于后端代码（虽然还是要依赖Node.js⋯⋯）的管理工具，对于前端开发者非常友好，例如：&lt;a href="http://yeoman.io/"&gt;YEMAN&lt;/a&gt;、&lt;a href="http://jamjs.org/"&gt;Jam&lt;/a&gt;、&lt;a href="http://volojs.org/"&gt;volo&lt;/a&gt;、&lt;a href="https://github.com/component/component"&gt;component&lt;/a&gt;、&lt;a href="http://brunch.io/"&gt;Brunch&lt;/a&gt;⋯⋯但是这些工具都或多或少有自己的一些问题，所以我决定用一些更轻量的工具（&lt;a href="http://twitter.github.com/bower/"&gt;bower&lt;/a&gt;、&lt;a href="http://gruntjs.com/"&gt;grunt&lt;/a&gt;）来搭建自己的前端开发流程。本文的例子来自本人正在开发的一个项目，可以在github上查看&lt;a href="https://github.com/zation/flyingtortoise"&gt;所有的代码&lt;/a&gt;。 &lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;如今的前端开发中，已经不再只是一些简单的静态文件了，对于很多Web App来说，前端代码甚至比后端代码要更加复杂，更加难于管理，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们有许多的第三方库的依赖需要管理；&lt;/li&gt;
&lt;li&gt;我们有独立的前端测试需要自动运行；&lt;/li&gt;
&lt;li&gt;我们还有很多代码需要在发布时进行打包压缩；&lt;/li&gt;
&lt;li&gt;⋯⋯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以构建一个自动化的前端开发流程是非常必要的，但现在前端开发流程的构建是百花齐放，没有一个统一的标准，还有很多依赖于后端的架构来做前端开发管理。例如在Rails开发中，就有各种前端库的gem包。但是这种依赖于后端框架的管理方式有许多问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;许多gem包的维护者并不是前端库的维护者，所以更新不一定即时；&lt;/li&gt;
&lt;li&gt;不利于前端代码与后端代码做分离；&lt;/li&gt;
&lt;li&gt;增加了前端开发者的学习和使用成本；&lt;/li&gt;
&lt;li&gt;⋯⋯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是现在出现了一些不依赖于后端代码（虽然还是要依赖Node.js⋯⋯）的管理工具，对于前端开发者非常友好，例如：&lt;a href="http://yeoman.io/"&gt;YEMAN&lt;/a&gt;、&lt;a href="http://jamjs.org/"&gt;Jam&lt;/a&gt;、&lt;a href="http://volojs.org/"&gt;volo&lt;/a&gt;、&lt;a href="https://github.com/component/component"&gt;component&lt;/a&gt;、&lt;a href="http://brunch.io/"&gt;Brunch&lt;/a&gt;⋯⋯但是这些工具都或多或少有自己的一些问题，所以我决定用一些更轻量的工具（&lt;a href="http://twitter.github.com/bower/"&gt;bower&lt;/a&gt;、&lt;a href="http://gruntjs.com/"&gt;grunt&lt;/a&gt;）来搭建自己的前端开发流程。本文的例子来自本人正在开发的一个项目，可以在github上查看&lt;a href="https://github.com/zation/flyingtortoise"&gt;所有的代码&lt;/a&gt;。 &lt;/p&gt;

&lt;h3&gt;什么是开发流程？&lt;/h3&gt;

&lt;p&gt;在我看来一个完整的开发流程应该包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;本地开发环境的初始化&lt;/li&gt;
&lt;li&gt;第三方依赖的管理&lt;/li&gt;
&lt;li&gt;源文件编译&lt;/li&gt;
&lt;li&gt;自动化测试&lt;/li&gt;
&lt;li&gt;发布到pipeline和各个环境&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而现代的开发流程，就是要使上面的各个部分都可以自动化，一个命令就可以使这些流程都自动走完，并且快速的得到错误或通过的反馈，让我们可以方便快速的修复错误和release。&lt;/p&gt;

&lt;h3&gt;本地开发环境的初始化&lt;/h3&gt;

&lt;p&gt;这里我使用的工具是&lt;a href="http://nodejs.org/"&gt;Node.js&lt;/a&gt;和&lt;a href="https://npmjs.org/"&gt;NPM&lt;/a&gt;，它们都基于JavaScript，使用Json来配置，对于前端开发人员非常友好。&lt;/p&gt;

&lt;p&gt;安装完成Node.js和NPM后，在项目根目录下创建NPM的配置文件&lt;code&gt;package.json&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;Project Name&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;Project Description&amp;quot;,
    &amp;quot;repository&amp;quot;: {
        &amp;quot;type&amp;quot;: &amp;quot;git&amp;quot;,
        &amp;quot;url&amp;quot;: &amp;quot;git://github.com/path/to/your_project&amp;quot;
    },
    &amp;quot;author&amp;quot;: &amp;quot;Author Name&amp;quot;,
    &amp;quot;license&amp;quot;: &amp;quot;BSD&amp;quot;,
    &amp;quot;readmeFilename&amp;quot;: &amp;quot;README.md&amp;quot;,
    &amp;quot;gitHead&amp;quot;: &amp;quot;git head&amp;quot;,
    &amp;quot;devDependencies&amp;quot;: {
        &amp;quot;grunt&amp;quot;: &amp;quot;latest&amp;quot;,
        &amp;quot;grunt-contrib-connect&amp;quot;: &amp;quot;latest&amp;quot;,
        &amp;quot;grunt-contrib-concat&amp;quot;: &amp;quot;latest&amp;quot;,
        &amp;quot;grunt-contrib-jasmine&amp;quot;: &amp;quot;latest&amp;quot;,
        &amp;quot;grunt-contrib-watch&amp;quot;: &amp;quot;latest&amp;quot;,
        &amp;quot;grunt-contrib-compass&amp;quot;: &amp;quot;latest&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中最重要的一个配置项是&lt;strong&gt;devDependencies&lt;/strong&gt;，这是用于开发的依赖，例如：自动化测试、源文件编译等等，其中各个依赖的作用和用法将会在后面讲到。而前端生产代码的依赖会使用另一个工具来管理，也在后面讲到。创建完成以后运行&lt;code&gt;npm install&lt;/code&gt;，NPM就会将这些依赖都安装到项目根目录的&lt;code&gt;node_modules&lt;/code&gt;文件夹中。&lt;/p&gt;

&lt;h3&gt;第三方依赖的管理&lt;/h3&gt;

&lt;p&gt;这里我使用的工具是&lt;a href="http://twitter.github.com/bower/"&gt;bower&lt;/a&gt;。其实NPM也可以管理，但是NPM并不是读取第三方依赖原始的repository，而是读取自己管理的一个repository，所以更新可能会慢点，并且它使用CommonJS的接口方便Node.js项目的开发，并不是针对纯前端开发的项目；而bower是读取原始的github repository，没有更新延迟的问题，所有包都是针对纯前端开发项目的。&lt;/p&gt;

&lt;p&gt;要使用bower只需要简单的三步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装：&lt;code&gt;npm install bower -g&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在项目根目录中创建配置文件&lt;code&gt;.bowerrc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在项目根目录中创建依赖配置文件&lt;code&gt;components.json&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们首先来看看&lt;code&gt;.bowerrc&lt;/code&gt;的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;directory&amp;quot; : &amp;quot;components&amp;quot;,
    &amp;quot;json&amp;quot;      : &amp;quot;component.json&amp;quot;,
    &amp;quot;endpoint&amp;quot;  : &amp;quot;https://bower.herokuapp.com&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;strong&gt;directory&lt;/strong&gt;指定了所有的依赖会被安装到哪里；&lt;strong&gt;json&lt;/strong&gt;指定了依赖配置文件的路径；&lt;strong&gt;endpoint&lt;/strong&gt;制定了依赖的repository的寻址服务器，你可以替换为自己的寻址服务器。&lt;/p&gt;

&lt;p&gt;然后我们来看看&lt;code&gt;components.json&lt;/code&gt;的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;Project Name&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
    &amp;quot;dependencies&amp;quot;: {
      &amp;quot;jquery&amp;quot;: &amp;quot;latest&amp;quot;,
      &amp;quot;underscore&amp;quot;: &amp;quot;latest&amp;quot;,
      &amp;quot;backbone&amp;quot;: &amp;quot;latest&amp;quot;,
      &amp;quot;jasmine-jquery&amp;quot;: &amp;quot;latest&amp;quot;,
      &amp;quot;jasmine-ajax&amp;quot;: &amp;quot;git@github.com:pivotal/jasmine-ajax.git&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中最重要的就是&lt;strong&gt;dependencies&lt;/strong&gt;，它指定了所有前端开发依赖的包。所有bower包含的依赖都可以在&lt;a href="http://sindresorhus.com/bower-components/"&gt;这里&lt;/a&gt;查到，对于bower没有包含的依赖也可以直接指定github的repository，例如：&lt;code&gt;&amp;quot;jasmine-ajax&amp;quot;: &amp;quot;git@github.com:pivotal/jasmine-ajax.git&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最后运行&lt;code&gt;bower install&lt;/code&gt;就可以在components文件夹中看到所有第三方依赖的文件了。但是bower有一个问题，就是它将所有github repository中的文件都下载下来了，其中有许多是我们不需要的文件。下面我们会将我们需要的文件提取出来打包放到我们指定的目录中。&lt;/p&gt;

&lt;h3&gt;源文件编译&lt;/h3&gt;

&lt;p&gt;这里我使用的工具是&lt;a href="http://gruntjs.com/"&gt;grunt&lt;/a&gt;，他本身主要是基于Node.js的文件操作包，其中有许多插件可以让我们完成js文件的compile和compress、sass到css的转换等等操作。要使用它需要先安装命令行工具：&lt;code&gt;npm install grunt-cli -g&lt;/code&gt;，然后在项目根目录中创建文件&lt;code&gt;Gruntfile.js&lt;/code&gt;，这个文件用于定义各种task，我们首先定义一个task将从bower下载的第三方依赖都打包到文件&lt;code&gt;app/js/lib.js&lt;/code&gt;中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt) {

    var dependencies = [
        &amp;#39;components/jquery/jquery.js&amp;#39;,
        &amp;#39;components/underscore/underscore.js&amp;#39;,
        &amp;#39;components/backbone/backbone.js&amp;#39;];

    grunt.initConfig({
        concat: {
            js: {
                src: dependencies,
                dest: &amp;#39;app/js/lib.js&amp;#39;
            }
        }
    });

    grunt.loadNpmTasks(&amp;#39;grunt-contrib-concat&amp;#39;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的grunt-contrib-concat就是grunt的一个插件，用于文件的合并操作，我们已经在前面的&lt;code&gt;package.json&lt;/code&gt;中引入了。&lt;code&gt;js&lt;/code&gt;是task name；&lt;code&gt;src&lt;/code&gt;指定了合并的源文件地址；&lt;code&gt;dest&lt;/code&gt;指定了合并的目标文件。这样当我们运行&lt;code&gt;grunt concat:js&lt;/code&gt;后，所有的依赖文件都会被合并为&lt;code&gt;app/js/lib.js&lt;/code&gt;。这样做的好处是我们可以控制每个依赖的引入顺序，但是麻烦的是每次引入新的依赖都需要手动加入到&lt;code&gt;dependencies&lt;/code&gt;数组中。这个暂时没有更好的解决方案，因为不是所有的包都在自己的&lt;code&gt;components.js&lt;/code&gt;中声明了main文件，很多时候必须自己手动指定。&lt;/p&gt;

&lt;p&gt;JavaScript文件编译完成以后就是CSS文件，在现代的前端开发中，我们已经很少直接写CSS文件了，一般都使用SASS或者LESS。grunt也提供了这种支持，这里我使用的是&lt;a href="https://github.com/gruntjs/grunt-contrib-compass"&gt;grunt-contrib-compass&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt) {

    var sasses = &amp;#39;sass&amp;#39;;

    grunt.initConfig({
        compass: {
            development: {
                options: {
                    sassDir: sasses,
                    cssDir: &amp;#39;app/css&amp;#39;
                }
            }
        }
    });

    grunt.loadNpmTasks(&amp;#39;grunt-contrib-compass&amp;#39;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行&lt;code&gt;grunt compass:development&lt;/code&gt;就可以完成CSS文件的编译了。&lt;/p&gt;

&lt;h3&gt;自动化测试&lt;/h3&gt;

&lt;p&gt;这里我使用的自动化测试工具是&lt;a href="http://pivotal.github.com/jasmine/"&gt;Jasmine&lt;/a&gt;，它grunt中同样有一个插件：&lt;a href="https://github.com/gruntjs/grunt-contrib-jasmine"&gt;grunt-contrib-jasmine&lt;/a&gt;。下面我们来看看如何在&lt;code&gt;Gruntfile.js&lt;/code&gt;中定义测试的task：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt) {

    var sources = &amp;#39;app/js/**/*.js&amp;#39;,
        specs = &amp;#39;spec/**/*Spec.js&amp;#39;;

    grunt.initConfig({
        jasmine: {
            test: {
                src: [sources],
                options: {
                    specs: specs,
                    helpers: [&amp;#39;spec/helper/**/*.js&amp;#39;],
                    vendor: &amp;#39;app/js/lib.js&amp;#39;
                }
            }
        }
    });

    grunt.loadNpmTasks(&amp;#39;grunt-contrib-jasmine&amp;#39;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置完成以后就可以运行&lt;code&gt;grunt jasmine:test&lt;/code&gt;来跑测试，但问题是每次写完代码都要手动执行一次非常麻烦，最好可以每次代码有更改都自动跑一次，让我们可以更快的得到反馈。grunt的&lt;a href="https://github.com/gruntjs/grunt-contrib-watch"&gt;watch插件&lt;/a&gt;就提供了这种支持：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(grunt) {

    var sources = &amp;#39;app/js/**/*.js&amp;#39;,
        specs = &amp;#39;spec/**/*Spec.js&amp;#39;;

    grunt.initConfig({
        jasmine: {
            test: {
                src: [sources],
                options: {
                    specs: specs,
                    helpers: [&amp;#39;spec/helper/**/*.js&amp;#39;],
                    vendor: &amp;#39;app/js/lib.js&amp;#39;
                }
            }
        },
        watch: {
            test: {
                files: [sources, specs],
                tasks: [&amp;#39;jasmine:test&amp;#39;]
            }
        }
    });

    grunt.loadNpmTasks(&amp;#39;grunt-contrib-jasmine&amp;#39;);
    grunt.loadNpmTasks(&amp;#39;grunt-contrib-watch&amp;#39;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;files&lt;/code&gt;指定了需要监听变动的文件；&lt;code&gt;tasks&lt;/code&gt;指定了修改后自动触发的task。现在只要我们运行&lt;code&gt;grunt watch:test&lt;/code&gt;，那么有任何源文件、测试文件的改动，Jasmine测试都会自动运行了。有时候我们也希望测试的结果显示在网页上，便于我们做js的调试。那么可以将&lt;code&gt;tasks: [&amp;#39;jasmine:test&amp;#39;]&lt;/code&gt;改为&lt;code&gt;tasks: [&amp;#39;jasmine:test:build&amp;#39;]&lt;/code&gt;，然后打开根目录下的&lt;code&gt;_SpecRunner.html&lt;/code&gt;文件，就可以在网页中看到测试结果了，再加上一些Chrome的&lt;a href="https://chrome.google.com/webstore/detail/live-reload/pccddenngcbofbojodpghgpbheckgddn"&gt;Livereload插件&lt;/a&gt;，就可以不用刷新实时的看到测试结果，效率非常之高。虽然grunt插件中也有&lt;a href="https://github.com/gruntjs/grunt-contrib-livereload"&gt;livereload&lt;/a&gt;，但是与grunt-contrib-watch无法很好的集成，所以我没有使用这种方式。&lt;/p&gt;

&lt;h3&gt;CI Pipeline&lt;/h3&gt;

&lt;p&gt;由于我的项目是host在github上，所以我选择&lt;a href="https://travis-ci.org/"&gt;travis-ci&lt;/a&gt;作为我的CI服务器。要启用travis-ci需要以下几步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在&lt;a href="https://travis-ci.org/"&gt;travis-ci&lt;/a&gt;中注册一个账号，获取一个token；&lt;/li&gt;
&lt;li&gt;在你的github项目的Settings--&amp;gt;Service Hooks中找到Travis，填入token并且启用；&lt;/li&gt;
&lt;li&gt;回到&lt;a href="https://travis-ci.org/"&gt;travis-ci&lt;/a&gt;，在Accounts--&amp;gt;Repositories中打开你的项目的service hook&lt;/li&gt;
&lt;li&gt;Push一个&lt;code&gt;.travis.yml&lt;/code&gt;到github，触发第一次build。&lt;/li&gt;
&lt;li&gt;修改&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scripts&lt;/code&gt;项，指定运行测试的命令&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们来看看如何配置&lt;code&gt;.travis.yml&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;language: node_js
node_js:
  - &amp;quot;0.8&amp;quot;
before_script:
  - npm install -g grunt-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们的环境是基于Node.js搭建的，所以在&lt;strong&gt;language&lt;/strong&gt;设置了node&lt;em&gt;js；而**node&lt;/em&gt;js&lt;strong&gt;指定了Node.js的版本；&lt;/strong&gt;before_script**指定了在测试运行前需要执行的命令，由于我们的脚本都是基于grunt的，所以需要先安装grunt的命令行包。&lt;/p&gt;

&lt;p&gt;然后再修改&lt;code&gt;package.json&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    ⋯⋯
    &amp;quot;scripts&amp;quot;: {
        &amp;quot;test&amp;quot;: &amp;quot;grunt jasmine:test&amp;quot;
    }
    ⋯⋯
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将修改以后的&lt;code&gt;package.json&lt;/code&gt;push到github上，再次触发一个新的build，你可以看到你之前错误的build已经绿了。&lt;/p&gt;

&lt;p&gt;这里还有一个小提示：如何让build状态显示在项目的readme中？很简单，只需要在README.md中加入以下代码就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[![Build Status](https://travis-ci.org/path/to/your_repository.png?branch=master)](http://travis-ci.org/path/to/your_repository)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里基本的环境搭建就完成了，当然我们还可以使用grund的&lt;code&gt;registerTask&lt;/code&gt;来定义一个任务序列，还可以加入template的编译⋯⋯这些都可以通过grunt来灵活设置。最重要的是现在别人拿到一个项目的代码以后，可以通过一些命令来快速的搭建本地环境，方便的进行测试和开发，而且没有依赖与后端的开发环境，只要定义好接口，前端开发可以完全独立开了。虽然这其中还有很多问题没有解决，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何让第三方依赖自申明main文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package.json&lt;/code&gt;与&lt;code&gt;components.json&lt;/code&gt;其实有些重复&lt;/li&gt;
&lt;li&gt;Live Reload还需要Chrome插件才能完成&lt;/li&gt;
&lt;li&gt;⋯⋯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这正是由于现在前端开发环境还没有后端开发的那种标准化，也正是挑战和机遇之所在！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>使用CSS3制作一个有趣的搜索框</title>
    <link rel="alternate" href="/2013/02/04/use_css3_to_create_innovation_search_box.html"/>
    <id>/2013/02/04/use_css3_to_create_innovation_search_box.html</id>
    <published>2013-02-04T05:29:00Z</published>
    <updated>2013-02-04T05:29:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="CSS3" src="/images/CSS3.png?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;动画效果在交互设计中占据着一个非常重要的位置，因为当我们在设计一个产品的时候，我们不仅仅是在设计它的外观，更是在设计它的行为。举例来说，一个好的演员可以利用他的动作、肢体语言使观众感受到角色的内心与特点，甚至将观众带入到相同的内心中，感同身受。同理，一系列好的动画设计，可以让使用者更容易了解产品的用法，感受到产品的特点，从而提升用户体验，甚至是让用户发出“Awesome! I love it！”的感叹。（关于动画到底是如何提升用户体验的，请看Alfredo Aponte的PPT：&lt;a href="http://www.slideshare.net/findfado/ux-enhancing-experiences"&gt;UX: Enhancing Experiences with Animation&lt;/a&gt;。）&lt;/p&gt;

&lt;p&gt;如今CSS3的日趋成熟，使我们制作网页中动画效果的方式更加的方便和多样，下面让我们来看看使用CSS3如何制作一个有趣的搜索框，所使用到的属性包括&lt;strong&gt;tansform&lt;/strong&gt;、&lt;strong&gt;animation&lt;/strong&gt;、&lt;strong&gt;keyframes&lt;/strong&gt;。最终效果情况本站右上角。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;img alt="CSS3" src="/images/CSS3.png?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;动画效果在交互设计中占据着一个非常重要的位置，因为当我们在设计一个产品的时候，我们不仅仅是在设计它的外观，更是在设计它的行为。举例来说，一个好的演员可以利用他的动作、肢体语言使观众感受到角色的内心与特点，甚至将观众带入到相同的内心中，感同身受。同理，一系列好的动画设计，可以让使用者更容易了解产品的用法，感受到产品的特点，从而提升用户体验，甚至是让用户发出“Awesome! I love it！”的感叹。（关于动画到底是如何提升用户体验的，请看Alfredo Aponte的PPT：&lt;a href="http://www.slideshare.net/findfado/ux-enhancing-experiences"&gt;UX: Enhancing Experiences with Animation&lt;/a&gt;。）&lt;/p&gt;

&lt;p&gt;如今CSS3的日趋成熟，使我们制作网页中动画效果的方式更加的方便和多样，下面让我们来看看使用CSS3如何制作一个有趣的搜索框，所使用到的属性包括&lt;strong&gt;tansform&lt;/strong&gt;、&lt;strong&gt;animation&lt;/strong&gt;、&lt;strong&gt;keyframes&lt;/strong&gt;。最终效果情况本站右上角。&lt;/p&gt;

&lt;h3&gt;使用transform绘制搜索框的“尾巴”&lt;/h3&gt;

&lt;p&gt;通常的搜索框图标都由一个圆圈加一个“尾巴”组成，例如下面的图片：&lt;/p&gt;

&lt;p&gt;&lt;img alt="Search Box" src="/images/search_box.png?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;一般我们都使用图片来完成这个效果，但是图片会给我们的动画效果造成很大的限制，所以这里我们使用CSS3来实现它。首先是HTML结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;search-container&amp;quot;&amp;gt;
    &amp;lt;input placeholder=&amp;quot;Search for article title or tags&amp;quot; class=&amp;quot;search&amp;quot; type=&amp;quot;text&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;search-qualifier&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里其实我希望只有一个&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;就可以实现，尾巴就在&lt;code&gt;input:after&lt;/code&gt;中实现，这样可以避免无意义的HTML标签。但是&lt;code&gt;:before&lt;/code&gt;和&lt;code&gt;:after&lt;/code&gt;这种伪类是将内容插入到某个容器中，但是如果这个容器是自闭和标签（例如：&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;），则这些伪类是不起效果的。所以这里我只能加入一个无意义的&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;，仅仅用于显示“尾巴”了。&lt;/p&gt;

&lt;p&gt;下面我们来看看如何将&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;变成一个圆圈（这里我就省略不同浏览器的前缀了）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.search {
    height: 18px;
    width: 18px;
    border-radius: 18px;
    background: white;
    border: 3px solid #999999;
    outline: none;
    padding: 3px;
    font-size: 0;
    box-shadow: inset 0 0 2px #999999, 0 0 2px #999999;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要将&lt;code&gt;border-radius&lt;/code&gt;设置为边长，或者大于边长，&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;就会变成一个圆圈了。&lt;/p&gt;

&lt;p&gt;下面我们将&lt;code&gt;&amp;lt;div class=&amp;quot;search-qualifier&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;设置为一个短横条，然后再将他以左边中心为原点顺时针旋转45度，一个搜索框的“尾巴”就出现了。来看看具体的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.search-qualifier {
     display: block;
     height: 8px;
     width: 0;
     border: 3px solid #999;
     border-radius: 3px;
     content: &amp;quot;&amp;quot;;
     position: absolute;
     top: 24px;
     right: 2px;
     transform: rotate(-45deg);
     transform-origin: 50% 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里要解释一下CSS3的新属性：&lt;strong&gt;transform&lt;/strong&gt;。它是用于对元素做2D或者3D变换的，包括旋转、缩放、移动和倾斜等等。&lt;code&gt;transform: rotate(-45deg)&lt;/code&gt;使&lt;code&gt;search-qualifier&lt;/code&gt;顺时针旋转45度，然后使用&lt;code&gt;transform-origin: 50% 0&lt;/code&gt;指定旋转的原点为左边的中心。具体可以参考&lt;a href="http://www.w3schools.com/cssref/css3_pr_transform.asp"&gt;w3schools&lt;/a&gt;上面的详细说明。&lt;/p&gt;

&lt;h3&gt;使用animation和keyframe让“尾巴”动起来&lt;/h3&gt;

&lt;p&gt;如果只是使用CSS3绘制这样的图形其实意义不大，与图片相比只是方便程序员调整大小，但是如果我们加入一些动画就不一样了，如果是好的动画效果，它会给用户心理上的惊喜，提高用户体验。下面我们就让“尾巴”可以左右摆动起来！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@keyframes qualifier-shaking {
    0% {
      transform: rotate(-75deg);
    }
    100% {
      transform: rotate(-30deg);
    }
}

.search-qualifier {
    ...
    animation: qualifier-shaking 1s infinite alternate;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里要解释一下CSS3的新属性：&lt;strong&gt;keyframes&lt;/strong&gt;和&lt;strong&gt;animation&lt;/strong&gt;。前者用于定义动画过程，后者用于调用动画。具体定义可以参考w3shcools：&lt;a href="http://www.w3schools.com/cssref/css3_pr_keyframes.asp"&gt;keyframes&lt;/a&gt;、&lt;a href="http://www.w3schools.com/cssref/css3_pr_animation.asp"&gt;animation&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我们首先利用&lt;code&gt;keyframes&lt;/code&gt;定义了一个名为“qualifier-shaking”的动画：在动画开始的时候，“尾巴”的旋转角度为75度，然后顺时针旋转到30度，动画结束。动画定义完成后，就是调用动画了，我们使用&lt;code&gt;animation&lt;/code&gt;来调用动画：“qualifier-shaking”表明了要调用的动画名称；“1s”是动画执行时间；“infinite”是动画执行次数，这里是执行无限次；“alternate”表明在动画多次执行过程中每次都是从头开始执行，还是以往复执行的方式。&lt;/p&gt;

&lt;p&gt;仅仅是左右摇摆还是太单调了一点，我们希望这个“尾巴”可以动得更调皮一些。首先他会隐藏起来，然后每隔一段时间冒个头，摇摆一下再缩回去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@keyframes qualifier-shaking {
    0% {
        height: 0;
        border-width: 0;
    }
    40% {
        height: 0;
        border-width: 0;
    }
    43% {
        transform: rotate(-45deg);
        height: 8px;
        border-width: 3px;
    }
    46% {
        transform: rotate(-75deg);
    }
    49% {
        transform: rotate(-30deg);
    }
    52% {
        transform: rotate(-45deg);
        height: 8px;
        border-width: 3px;
    }
    57% {
        transform: rotate(-45deg);
        height: 8px;
        border-width: 3px;
    }
    60% {
        height: 0;
        border-width: 0;
    }
    100% {
        height: 0;
        border-width: 0;
    }
}

.search-qualifier {
    ...
    animation: qualifier-shaking 6s infinite;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们设置更多的动画段，首尾两端都让“尾巴”隐藏，然后利用&lt;code&gt;height&lt;/code&gt;和&lt;code&gt;border-width&lt;/code&gt;的改变让“尾巴”冒头和缩回，其余都跟上一个例子相同。这里的animation也设置了更长的执行时间。&lt;/p&gt;

&lt;p&gt;到此为止，一个有趣的CSS3搜索框就做好了。在现代的前端开发中，CSS已经可以完成动画的操作了，那么我们就尽量用CSS来完成，js最多就只用作改变class来触发动画。因为现在js负责的前端逻辑处理已经很多了，再给js加上动画处理的代码很容易导致项目js代码的爆炸。同时CSS3动画有来自浏览器自身的支持，效率和效果上都会 更好一些。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>数独生成浅尝</title>
    <link rel="alternate" href="/2013/01/28/sudoku_arithmetic_research.html"/>
    <id>/2013/01/28/sudoku_arithmetic_research.html</id>
    <published>2013-01-28T01:28:00Z</published>
    <updated>2013-01-28T01:28:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Sudoku" src="/images/sudoku/cover.jpg?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;数独是一种非常有意思的游戏，也是我很喜欢的一种游戏，当闲来无事的时候，常常会打开手机里的数独游戏来打发时间。当我们在享受数独游戏的时候，有没有想过每一局游戏是如何生成的呢？看似简单，其实很复杂。有不少相关的算法，还有一个困惑了数学家多年的谜题（2011年12月被解开）。下面就让我们一起来看看数独的生成。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Sudoku" src="/images/sudoku/cover.jpg?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;数独是一种非常有意思的游戏，也是我很喜欢的一种游戏，当闲来无事的时候，常常会打开手机里的数独游戏来打发时间。当我们在享受数独游戏的时候，有没有想过每一局游戏是如何生成的呢？看似简单，其实很复杂。有不少相关的算法，还有一个困惑了数学家多年的谜题（2011年12月被解开）。下面就让我们一起来看看数独的生成。&lt;/p&gt;

&lt;h3&gt;什么是数独&lt;/h3&gt;

&lt;p&gt;可能有些朋友还不知道什么是数独，下面是来自&lt;a href="http://zh.wikipedia.org/wiki/%E6%95%B8%E7%8D%A8"&gt;维基百科&lt;/a&gt;的解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;數獨 Sudoku（数独，sūdoku，すうどく）&lt;/p&gt;

&lt;p&gt;/suːˈdoʊkuː/soo-DOH-koo是一種邏輯性的數字填充遊戲，玩家須以數字填進每一格，而每行、每列和每個宮（即3x3的大格）有齊1至9所有數字。遊戲設計者會提供一部份的數字，使謎題只有一個答案。&lt;/p&gt;

&lt;p&gt;一個已解答的數獨其實是一種多了宮的限制的拉丁方陣，因為同一個數字不可能在同一行、列或宮中出現多於一次。&lt;/p&gt;

&lt;p&gt;这种游戏只需要逻辑思维能力，与数字运算无关。虽然玩法简单，但数字排列方式却千变万化，所以不少教育者认为数独是锻炼脑筋的好方法。因为数独上的数字没有运算价值，仅仅代表相互区分的不同个体，因此可以使用其他的符号比如拉丁字母、罗马字母甚至是不图形状的图案代替。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是一个数独的题目以及解答：&lt;/p&gt;

&lt;p&gt;&lt;img alt="Sudoku Example" src="/images/sudoku/example.png?1401972413" /&gt;
&lt;img alt="Sudoku Solution" src="/images/sudoku/solution.png?1401972413" /&gt;&lt;/p&gt;

&lt;h3&gt;如何生成数独的解答&lt;/h3&gt;

&lt;p&gt;要生成一个数独，直接生成它的迷局比较困难，我们可以先从解答开始。当我们看到数独的时候，就会发现他其实就是一种数学矩阵，当我们在考虑如何生成数独的时候，也可以从矩阵变换的角度来考虑。我们可以从一个完成的数独开始，例如：&lt;/p&gt;

&lt;p&gt;&lt;img alt="Sudoku Origin" src="/images/sudoku/origin.jpg?1401972413" /&gt;&lt;/p&gt;

&lt;p&gt;对于这个9x9的矩阵，我们现在要考虑的就是如何打乱每个数字的位置，而不破坏它的规律——每行、每列、每宫都有1至9的所有数字。符合这个条件的矩阵变化有以下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;交换每组（1-3行为一组，4-6行为一组，7-9行为一组）中的任意两行：&lt;/p&gt;

&lt;p&gt;&lt;img alt="Sudoku Transform 1" src="/images/sudoku/transform1.jpg?1401972413" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同样也可以交换每组中的任意两列。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组之间的行互换：&lt;/p&gt;

&lt;p&gt;&lt;img alt="Sudoku Transform 2" src="/images/sudoku/transform2.jpg?1401972413" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同样也可以组之间的列互换。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;矩阵转置：&lt;/p&gt;

&lt;p&gt;&lt;img alt="Sudoku Transform 3" src="/images/sudoku/transform3.jpg?1401972413" /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几乎各种编程语言都会有矩阵计算的库，由于本人比较专注于JavaScript，所以这里推荐一个JavaScript的矩阵计算库：&lt;a href="http://sylvester.jcoglan.com/"&gt;Sylvester&lt;/a&gt;，有了矩阵计算库的支持，再加上前面几种等价变换，我们可以很容易生成出一个数独的结局。&lt;/p&gt;

&lt;h3&gt;如何生成数独的迷局&lt;/h3&gt;

&lt;p&gt;结局生成好了以后，下一步就是要清空其中的某些数字格，从而生成迷局，这是最难也最有讲究的。数独游戏有一个“潜规则”：每个游戏只能有一个解答，如果有两个或者以上的解答，那么游戏的难度将会降低。所以我们在清空数字格的时候也不能随意的清空，我们必须保证它最后只有唯一解。&lt;/p&gt;

&lt;p&gt;很遗憾的是，在我的能力范围之内以及搜索范围内没有找到有哪种算法可以保证数独只有唯一解，也没有某种算法可以验证一个谜题是否一定有多个解（除非有一组三行全为空）。不过一些研究标明，有某种pattern会导致数独一定有多个解，请见&lt;a href="http://www.sudoku.org.uk/SolvingTechniques/UniqueRectangles.asp"&gt;“Deadly Pattern”&lt;/a&gt;。我们可以做的有以下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;保证在去掉数字格的过程中不会同时去掉一组的三行&lt;/li&gt;
&lt;li&gt;使用Solver验证生成的迷局是否有多个解&lt;/li&gt;
&lt;li&gt;当出现“Deadly Pattern”时，撤销上一次去掉数字格的操作，重新去掉一个新的，再次回到上一步做验证&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;数独的数学谜题&lt;/h3&gt;

&lt;p&gt;这里还有一个困扰了数学家数十年的问题：&lt;strong&gt;数独游戏最少需要多少个数字，才能保证最后有唯一解？&lt;/strong&gt;曾经有数学家找到过17个数字并且具有唯一解的数独，但是一直没有找到16个数字的唯一解数独。于是部分数学家相信17个数字就是唯一解数独的最少数字了，也有数学家任然在寻找16个数字的唯一解数独，只是一直都无法证明17这一最少数字，也一直没有找到16个数字的唯一解数独。&lt;/p&gt;

&lt;p&gt;这个谜题终于在2011年12月被Gary McGuire以及他在都柏林大学的朋友们一起破解了，他们利用计算机程序遍历了所有16数字的数独，最终没有发现唯一解数独，从而以穷举的方式证明了&lt;strong&gt;数独游戏最少需要17个数字，才能保证最后有唯一解。&lt;/strong&gt;他们利用对称性去掉了所有等价的数独，任然计算了5,472,730,538次以及一年的时间才得到这个结果。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.forret.com/2006/08/a-sudoku-challenge-generator/"&gt;A Sudoku challenge generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.technologyreview.com/view/426554/mathematicians-solve-minimum-sudoku-problem/"&gt;Mathematicians Solve Minimum Sudoku Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
