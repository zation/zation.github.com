<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
  <title>Zation's Blog</title>

  <link href="/stylesheets/main.css" media="screen" rel="stylesheet" type="text/css" />
  <script src="/javascripts/main.js" type="text/javascript"></script>
  <link href="/images/images/favicon.png" rel="icon" type="image/png" />
</head>

<body>
  <div class="main-container">
    <header class="nav-container">
      <a class="logo" href="/">data.page.title</a>
    </header>

    <section class="content">
        <article class="article">
    <ul class="extro-info">
      <li class="date">
        Jan 09, 2013 
      </li>
      
    </ul>
    <header class="article-title">
      <h1>
        <a href="/2013/01/09/sass_compass_best_practise_2.html">Sass & Compass Best Practise 2</a>
      </h1>
      
        <h2>——简化代码</h2>
      
    </header>
    <div class="article-content">
      <p><a href="/2013/01/07/sass_compass_best_practise_1.html">前一篇文章</a>中我们介绍了如何利用Sass来组织我们的代码结构，本文中将会介绍如何利用Compass来简化我们的CSS代码。</p>

<h3>简化兼容性代码</h3>

<p>当我们在用CSS实现渐变效果时，为了浏览器的兼容性，我们常常会用以下写法：</p>

<pre><code>/* FF3.6+ */
background: -moz-linear-gradient(top, #1e5799 0%, #2989d8 50%, #207cca 51%, #7db9e8 100%);
/* Chrome,Safari4+ */ 
background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#1e5799), color-stop(50%,#2989d8), color-stop(51%,#207cca), color-stop(100%,#7db9e8)); 
/* Chrome10+,Safari5.1+ */
background: -webkit-linear-gradient(top, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%); 
/* Opera 11.10+ */
background: -o-linear-gradient(top, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%); 
/* IE10+ */
background: -ms-linear-gradient(top, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%); 
/* W3C */
background: linear-gradient(to bottom, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%); 
/* IE6-9 */
filter: progid:DXImageTransform.Microsoft.gradient( startColorstr=&#39;#1e5799&#39;, endColorstr=&#39;#7db9e8&#39;,GradientType=0 ); 
</code></pre>

<p>一个简单的渐变，就为了兼容性，变成了超过10行的CSS代码，并且让我们维护起来非常麻烦，一旦有任何修改，我们都必须改7个地方⋯⋯好在Compass为我们提供了解决方案，我们只需要一行代码就可以：</p>

<pre><code>@include background-image(linear-gradient(top, #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%)); 
</code></pre>

<p>类似的功能可以用在box-shadow：<code>@include box-shadow(red 2px 2px 10px);</code>、inline-block：<code>@include inline-block</code>、border-radius：<code>@include border-radius(25px);</code>⋯⋯等等</p>

<h3>适当的使用nest</h3>

<p>在CSS中我们常常需要限制样式的作用范围，例如：</p>

<pre><code>.container {
    ⋯⋯
}
.container .article {
    ⋯⋯
}
.container .article .content {
    ⋯⋯
}
.container .article .paragraph {
    ⋯⋯
}
.container .article .link {
    ⋯⋯
}
</code></pre>

<p>这样书写在CSS中没有问题，但是重复的书写<code>.container</code>和<code>.article</code>总会让人感到厌倦，并且使同一部分的样式很容易散落在各处，不容易管理。这时候我们就可以使用nest了，它可以帮助我们：</p>

<ul>
<li>将同一部分的样式归总到一起，方便阅读和维护</li>
<li>消除重复的selector，特别是父元素的selector</li>
</ul>

<p>下面我们来看看使用nest以后的代码：</p>

<pre><code>.container {
    ⋯⋯
    .article {
        ⋯⋯
        .content {
            ⋯⋯
        }
        .paragraph {
            ⋯⋯
        }
        .link {
            ⋯⋯
        }
    }
}
</code></pre>

<p>但是切忌不要过分的使用nest，如下：</p>

<pre><code>.container {
    ⋯⋯
    .article {
        ⋯⋯
        .content {
            ⋯⋯
            .paragraph {
                ⋯⋯
                .link {
                    ⋯⋯
                }
            }
        }       
    }
}
</code></pre>

<p>它会使最后生成出这样的CSS：</p>

<pre><code>.container {
    ⋯⋯
}
.container .article {
    ⋯⋯
}
.container .article .content {
    ⋯⋯
}
.container .article .content .paragraph {
    ⋯⋯
}
.container .article .content .paragraph .link {
    ⋯⋯
}
</code></pre>

<p>我们看到最后生成的CSS甚至出现了5层selector，一般CSS中出现3层selector已经是比较多了，因为太多的selector会使CSS文件变得冗余，可读性也会变差，而且很难被复用。当你真的需要这么多selector才能完成需求的话，那么你应该反思你的HTML结构是否出现了问题？</p>

<h3>谨慎的使用@extend</h3>

<p><code>@extend</code>可以使我们很方便的复用其他元素的样式，假如我们现在有如下的CSS：</p>

<pre><code>h1, h2 {
    font-family: Arial;
    font-size: 38px;
    color: #222;
}
h2 {
    font-size: 24px;
}
</code></pre>

<p>我们可以使用<code>@extend</code>使代码看起来依赖关系更清晰，并且稍微简单一些（但它实际生成的CSS代码与前相同）：</p>

<pre><code>h1 {
    font-family: Arial;
    font-size: 38px;
    color: #222;
}
h2 {
    @extend h1;
    font-size: 24px;
}
</code></pre>

<p>它有些类似于<code>@mixin</code>，不同在于它自身也是CSS，会被页面直接用到。它的目的在于消除重复，并且使依赖关系更加清晰。但是在使用的时候一定要谨慎，因为一个<code>@extend</code>可以很方便的复用代码，人们往往直接这么一用，也不管是否被复用的所有样式都是需要的，也不管最终生成的CSS是否有冗余。所以我们在使用它的时候请先想想一下问题：</p>

<ul>
<li>是否所有的CSS属性都是我所需要的，否则的话复制粘贴其中一部分也不会花太多功夫，不要为了消除重复反而造成冗余</li>
<li>我所继承的样式中是否还继承了其他样式，不要有多重继承的情况，这样会导致代码理解变得困难</li>
<li>最终生成的CSS代码是否有selector过长的情况，不要写到最后写成了一个reset⋯⋯</li>
</ul>

<p>鉴于<code>@extend</code>有这样那样的问题，虽然它还是有一定的作用，但是建议用之前一定要谨慎。</p>

    </div>
  </article>
  <article class="article">
    <ul class="extro-info">
      <li class="date">
        Jan 07, 2013 
      </li>
      
    </ul>
    <header class="article-title">
      <h1>
        <a href="/2013/01/07/sass_compass_best_practise_1.html">Sass & Compass Best Practise 1</a>
      </h1>
      
        <h2>——组织结构</h2>
      
    </header>
    <div class="article-content">
      <p>在CSS开发中你有没有遇到以下问题：</p>

<ul>
<li>一个CSS文件几百上千行，要修改一个样式要找半天；</li>
<li>为了不同浏览器的兼容性，同样的样式要写好几行代码；</li>
<li>为了防止背景图片被缓存，每次更改背景图片都要修改图片名称和代码；</li>
<li>当sprites修改以后，在代码中需要调试半天background-position才能适应新的sprites；</li>
<li>⋯⋯</li>
</ul>

<p>当你遇到其中一个或多个问题的时候，说明在CSS代码的管理和维护上出了问题。而这个时候，传统的CSS开发方式已经无法满足这些需求了，我们需要新的开发框架和工具，也就是：<a href="http://sass-lang.com/">Sass</a>、<a href="http://compass-style.org/">Compass</a>！</p>

<p>关于Sass和Compass的基本用法，阮一峰有两片写的很好的简介：<a href="http://www.ruanyifeng.com/blog/2012/06/sass.html">SASS用法指南</a>、<a href="http://www.ruanyifeng.com/blog/2012/11/compass.html">Compass用法指南</a>。这里就不再赘述了，下面我想介绍一系列我们在使用Sass和Compass方面的最佳实践，本文为第一篇：如何模块化CSS代码，使我们的样式也有一个良好的组织结构。</p>

<h3>问题</h3>

<p>我们在写程序的时候，总是希望可以清楚的了解模块之间的依赖，这样可以方便程序人员理解代码，也方便监控我们的依赖不要过多。假设我们页面的CSS代码已经根据组件和功能划分为不同的模块和CSS文件，其中还有一些第三方的CSS库（reset）：</p>

<pre><code>style/
    reset.css
    layout.css
    menu.css
    document.css
    form/
        form.css
        button.css
        input.css
</code></pre>

<p>相对应的页面<code>header</code>就会有如下的引用：</p>

<pre><code>&lt;header&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style/reset.css&quot;/&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style/layout.css&quot;/&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style/menu.css&quot;/&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style/document.css&quot;/&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style/form/form.css&quot;/&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style/form/button.css&quot;/&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style/form/input.css&quot;/&gt;
&lt;/header&gt;
</code></pre>

<p>这样我们所有的依赖都在HTML中，不利于我们快速的看到样式之间的依赖，也会产生很多额外的HTTP请求，降低页面性能。我们也可以使用<code>@import</code>在CSS文件内部管理引用，但这同样会产生额外的HTTP请求。</p>

<h3>解决方案</h3>

<p>当我们希望在CSS代码中就管理所有依赖，并且不会产生额外的request时，就应该用到Sass了。
下面我们看看如果使用了Sass应该是什么样子的：</p>

<pre><code>style/
    screen.scss
    _reset.scss
    _layout.scss
    _menu.scss
    _document.scss
    form/
        _form.scss
        _button.scss
        _input.scss
</code></pre>

<p>在<code>_form.scss</code>中，我们将管理所有的表单及表单控件的样式：</p>

<pre><code>@import &quot;button&quot;;
@import &quot;input&quot;;

form {
    ⋯⋯
}
</code></pre>

<p>在<code>screen.scss</code>中，我们将管理所有页面样式的依赖：</p>

<pre><code>@import &quot;reset&quot;;
@import &quot;layout&quot;;
@import &quot;menu&quot;;
@import &quot;document&quot;;
@import &quot;form&quot;;
</code></pre>

<p>其中文件名前面的下划线是告诉Sass该文件只是一个模块，不用单独生成css文件，所以最后生成的css文件只有一个：<code>screen.css</code>，于是我们只需要一个request就可以引入所有的css文件，写起来也非常方便：</p>

<pre><code>&lt;header&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style/screen.css&quot;/&gt;
&lt;/header&gt;
</code></pre>

<p>可能有人会担心这样调试起来会不会很麻烦？但其实如果我们使用Chrome的inspection，我们根本不必接触源代码就可以很好的调试了。</p>

<p>同时，Compass已经提供了丰富的CSS库，其中包括了rese，所以我们可以直接删除<code>_reset.scss</code>，只在<code>screen.scss</code>中引入就可以了。</p>

<h3>总结</h3>

<p>下面我们来总结一下在使用Sass帮助我们组织代码结构的时候应该注意的地方：</p>

<ul>
<li>将CSS代码按照功能和组件划分为不同的模块，每个模块为一个文件，模块的文件名都以下划线开头，避免Sass生成额外的CSS文件</li>
<li>当一个模块的代码过多的时候，将之拆分为不同的子模块，并且在一个主模块中管理所有依赖，如：<code>_form.scss</code></li>
<li>不要有太多的层级，那样会影响代码的可读性，通常三层已经是极限了</li>
<li>讲所有第三方引用的库都放在一个文件管理，例如：<code>screen.scss</code>，即使只有一个模块用到了它。因为重复的引用会在最后生成额外的CSS代码，而在众多的子模块中查找是否已经引入了某个库会非常麻烦，也不便于管理</li>
</ul>

<p>这样既模块化了CSS代码，相互之间的依赖又非常清晰，而且还没有增加额外的request，不失为一个最佳实践。</p>

    </div>
  </article>
  <article class="article">
    <ul class="extro-info">
      <li class="date">
        Dec 31, 2012 
      </li>
      
    </ul>
    <header class="article-title">
      <h1>
        <a href="/2012/12/31/不在这里重生，就在这里死去.html">不在这里重生，就在这里死去</a>
      </h1>
      
        <h2>——我在ThoughtWorks的2012</h2>
      
    </header>
    <div class="article-content">
      <p><img alt="2012" src="/images/2012.png" /></p>

<p>在2012的尾巴上回头看去，这几乎就是工作的一年。整整一年我都在西安出差，除了偶尔回成都见见朋友和亲人，就是在公寓与公司之间工作、学习。但这样的一年里，我却有了很多新的尝试和改变：</p>

<ul>
<li>我在西安电子科技大学给大学生做了演讲</li>
<li>我在公司做了两次系统的CSS Session</li>
<li>翻译了《HTML5 Mobile Development Cookbook》</li>
<li>在Openparty上show了一把现场写jasmine测试</li>
<li>学习了别人听都没听过的乐器——陶笛</li>
<li>通宵爬上了华山，却在穿越莫不知名的山峰时以为自己就要死在上面</li>
<li>我开始阅读经济、创业方面的书籍</li>
<li>⋯⋯</li>
</ul>

<p>但是更多的，使我思维和观念的转变。</p>

<h3>学习的最好检验方式，就是把你学到的讲出来。</h3>

<p>记得刚进入公司的时候，就被大大叫到了小黑屋，布置了每周一个前端开发Session的任务。其实那个时候我对于前端开发并没有特别系统的认识，但还是答应下来。接着就是各种查资料和准备，但除了第一次讲得还行，其他的无论是Session还是Code Jam都不是很理想。最后发现真正收获最多的人是我自己，我终于把以前零散的知识系统的组织起来，而驱使我不断思考不断总结的，就是因为我要把它们讲出来。</p>

<ul>
<li>在准备的过程中，我会把自己假象为听众，去思考他们会有什么样的问题，这时才发现其实还有很多东西我了解的不是很清楚，于是我不断深钻，研究了所有可能的问题和知识点，再不是以前的浅尝辄止，够用就行。</li>
<li>在讲解的过程中，我的目的是让别人可以学习和理解我的知识。但如果只是零散的知识，那是不便于别人的理解的，这就需要我自己首先把所有的知识组织起来，总结为一个系统化的“理论”，这种“理论”不需要太深奥，只需要各个知识点都相互关联，又有逐渐深入的示例，别人就很容易理解了。</li>
<li>在讲解完成以后，别人会给我各种反馈，这些反馈不光是针对技术的，还有针对演讲技巧。它们可以启发我的思考，让我可以持续的对各个方面进行改进。</li>
</ul>

<p>最终能称得上比较成功的，是两次关于CSS的系列培训，新的一年里我会将它们带到成都办公室，进行新的一轮培训。每一次的培训都是我对自己知识体系的一次完善；都是我对培训方式的一次尝试；也是我对自己表达力、影响力的一次锻炼。</p>

<h3>用别人的思想，启发自己的思维</h3>

<p>曾经只读小说和技术书籍的我，今年终于开始涉猎创业和设计方面的书籍：《精益创业》、《简约至上》、《瞬间之美》、《认知与设计》。我才发现对于启发思维，书籍是非常好的工具。其中《精益创业》对我的启发最大，读完以后我才认识到原来我们传统的产品开发模式中有如此多的浪费，其最大的浪费之处不在于效率太低，而在于我们高效率的工作在错误的方向之上，却不自知也不改变。</p>

<p>新的一年里我准备了更多创业和经济方面的书籍：《四步创业法》、《商业模式新生代》、《黑天鹅》等等，希望我可以对于自己所作的事情有更好的价值评估，对于未来的价值走向也能有一些感觉。</p>

<h3>“Coding for fun, not coding for 饭”</h3>

<p>进入ThoughtWorks，注定了我要开始对于技术的狂热追求，在这一年里我参与/创建了27个github repositories，学会了把Web应用发布到各种云平台上，例如Heroku、Cloud Foundry。</p>

<p>在这里，我终于知道了什么是MVC，并且用在项目中利用Backbone.js做了实践；我参加了OO Bootcamp，终于了解了什么才是面向对象编程；我体验了敏捷开发方式：敏捷流程、持续集成、重构、自动化测试，终于体会到了先进的开发方式给整个IT行业带来的触动。</p>

<p>细数今年那些我使用过的技术：Angular.js、Backbone.js、Sass、Compass、Rails、Redis、Responsive Design、Parallax Scrolling⋯⋯虽然并不是每个我都有非常深入的研究，但这一年是我有生以来在技术上走得最深最广的一年，感谢我的客户，我的同事们，让我感受到了代码的乐趣，借用凯桑的一句话：“Coding for fun, not coding for 饭”。</p>

<h3>2013</h3>

<p>从2012到2013，从一个20出头的愣头青倒向了奔往30的欧吉桑，新的一年中我希望自己有更多新的尝试，体验新的办公室，与新的同事合作，实践Lean Startup，尝试Inception，更加深入系统化的前端开发，也往移动开发方面发展⋯⋯</p>

<p>“一转眼，前程似茧”，往年每每都会有这样那样的低谷，让我在心里默默的唱着这句歌词，而今年渐渐的淡忘了这首歌。来年回望，更上一层。</p>

    </div>
  </article>


    </section>
  </div>

  <footer class="page-footer">
  </footer>
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-8993667-6']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>
</body>
</html>