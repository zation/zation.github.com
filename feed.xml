<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zation's Blog</title>
  <subtitle>Coding for fun</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://zation.me/"/>
  <link href="http://zation.me/feed.xml" rel="self"/>
  <updated>2015-05-06T14:41:00Z</updated>
  <author>
    <name>Zation</name>
  </author>
  <entry>
    <title>如何在阿里云上部署私有的Docker Registry</title>
    <link rel="alternate" href="/2015/05/06/how_to_deploy_docker_registry_on_aliyun.html"/>
    <id>/2015/05/06/how_to_deploy_docker_registry_on_aliyun.html</id>
    <published>2015-05-06T14:41:00Z</published>
    <updated>2015-05-06T14:41:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img title="Aliyun and Docker" alt="Aliyun and Docker" src="/images/aliyun_docker.png?1431086065" /&gt;&lt;/p&gt;

&lt;p&gt;关于什么是Docker，为什么要使用Docker，使用Docker的基础知识这里就先不赘述了，有很多的参考资料都有了详尽的介绍，比如说这本Gitbook：&lt;a href="https://www.gitbook.com/book/yeasy/docker_practice/details"&gt;《
Docker —— 从入门到实践》&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这里先简要介绍一下为什么要在阿里云上部署私有的Docker Registry：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href="https://registry.hub.docker.com/"&gt;Docker Hub&lt;/a&gt;来存放Docker Image，经常会出现Push/Pull timeout，你们懂的；&lt;/li&gt;
&lt;li&gt;我司现在各个Server都是放在阿里云上的，如果我们把Docker Registry也放在阿里云上，那么我们做release的速度就会相当快；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;背景介绍完了，下面我们就来看看具体如何部署吧。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;img title="Aliyun and Docker" alt="Aliyun and Docker" src="/images/aliyun_docker.png?1431086065" /&gt;&lt;/p&gt;

&lt;p&gt;关于什么是Docker，为什么要使用Docker，使用Docker的基础知识这里就先不赘述了，有很多的参考资料都有了详尽的介绍，比如说这本Gitbook：&lt;a href="https://www.gitbook.com/book/yeasy/docker_practice/details"&gt;《
Docker —— 从入门到实践》&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这里先简要介绍一下为什么要在阿里云上部署私有的Docker Registry：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href="https://registry.hub.docker.com/"&gt;Docker Hub&lt;/a&gt;来存放Docker Image，经常会出现Push/Pull timeout，你们懂的；&lt;/li&gt;
&lt;li&gt;我司现在各个Server都是放在阿里云上的，如果我们把Docker Registry也放在阿里云上，那么我们做release的速度就会相当快；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;背景介绍完了，下面我们就来看看具体如何部署吧。&lt;/p&gt;

&lt;h3&gt;什么是Docker Registry&lt;/h3&gt;

&lt;p&gt;也许一些Docker的新人，对于什么是Registry还不太清楚，这里我大概讲解一下，了解的人可以直接略过这一部分了。&lt;/p&gt;

&lt;p&gt;Docker Registry就是可以存放很多Docker Repository的服务器。举个例子，比如我们在内网192.168.0.1的5000端口上创建了一个Registry，并且其中有一个ubuntu 12.04的Image，那么我们就可以用下面这个命令来获取它：&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ docker pull 192.168.0.1:5000/ubuntu:12.04
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;strong&gt;192.168.0.1:5000&lt;/strong&gt;就是Registry的服务器地址和端口，&lt;strong&gt;ubuntu&lt;/strong&gt;就是Repository的名字，&lt;strong&gt;12.04&lt;/strong&gt;指示了版本号，也具体指向了一个Image。所以也可以这么理解：定位一个Image的方式是Registry + Repository + Version。&lt;/p&gt;

&lt;p&gt;Docker Registry主要有两种：公开的和私有的。最大的公开Registry就是&lt;a href="https://registry.hub.docker.com/"&gt;Docker Hub&lt;/a&gt;，不过他也提供了私有Registry的服务，每个帐号可以有一个免费的Private Image，如果多了就要付费。但是对于国内来说他是基本很难连上的。私有Registry就是个人或者公司搭建的，通过网络隔离或者某种认证手段，只允许内部访问。&lt;/p&gt;

&lt;h3&gt;在阿里云上安装Docker&lt;/h3&gt;

&lt;p&gt;由于我们的Registry会使用最新的2.0版本，所以安装的Docker也必须是最新的1.6版本，apt-get还是1.5，所以这里我们使用官方的脚本进行安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;wget -qO- https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成以后你会发现，再启动Docker的时候有报错：&lt;/p&gt;

&lt;pre&gt;&lt;code class="log"&gt;Could not find a free IP address range for xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没错，这就是阿里云的坑，具体原因和解决方案可以参考&lt;a href="http://hanjianwei.com/2014/07/30/docker-on-aliyun/"&gt;这里&lt;/a&gt;，简单来说的话就是：修改&lt;code&gt;/etc/network/interface&lt;/code&gt;，去掉172那段的路由，然后运行&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ route del -net 172.16.0.0/12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在运行&lt;code&gt;$ service docker start&lt;/code&gt;就可以启动Docker了。&lt;/p&gt;

&lt;h3&gt;安装并运行Docker Registry&lt;/h3&gt;

&lt;p&gt;在服务器上安装Docker Registry主要有两种方式：本地安装；通过Image安装。这里我推荐用Image安装，因为安装最快，启动也方便。&lt;/p&gt;

&lt;p&gt;Docker官方已经很贴心的将一个完整的Docker Registry打包成了一个Image，我们只需要把它run起来就“可以了”：&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ docker run -d -p 5000:5000 registry:2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后Docker会检查你本地有没有registry:2.0这个镜像，如果没有的话它就会默认从Docker Hub上面Pull下来，然后就会run起来了。&lt;/p&gt;

&lt;p&gt;安装和启动完成以后，可以访问一下&lt;a href="http://localhost:5000/v2/"&gt;http://localhost:5000/v2/&lt;/a&gt;，如果看到服务器返回了一个空的JSON&lt;code&gt;{}&lt;/code&gt;，那么说明运行已经成功了。大家以为大功就要告成了吗？其实征途才刚刚开始啊！&lt;/p&gt;

&lt;h3&gt;从本地把Image Push到Docker Registry中&lt;/h3&gt;

&lt;p&gt;我是万万没有想到，这临门一脚的一步，却是最难的一步，也是最费时间精力的一步，我为什么要写这篇博客，就是希望大家可以在这一步少走弯路。&lt;/p&gt;

&lt;p&gt;假设我们现在本地有一个叫做hello-world的Image，而我们阿里云上的Registry的IP是120.1.1.1，端口是5000。当我们想要把hello-world Push到阿里云的Registry中时，首先我们要指定它的Registry：&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ docker tag hello-world:latest 120.0.0.1:5000/hello-world:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们很自然的就会去运行Push命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ docker push 120.0.0.1:5000/hello-world:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是你就看到下面这个错误了：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;FATA[0000] Error response from daemon: v1 ping attempt failed with error: Get https://120.0.0.1:5000/v1/_ping: tls: oversized record received with length 20527. If this private registry supports only HTTP or HTTPS with an unknown CA certificate, please add &lt;code&gt;--insecure-registry 120.0.0.1:5000&lt;/code&gt; to the daemon&amp;#39;s arguments. In the case of HTTPS, if you have access to the registry&amp;#39;s CA certificate, no need for the flag; simply place the CA certificate at /etc/docker/certs.d/120.0.0.1:5000/ca.crt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是由于我们并没有把一个通过认证的安全证书加到Registry服务器中。这里就涉及到如何添加安全证书，以及如何设置安全认证，关于这两点官方都有很详尽的文档，可以参考&lt;a href="https://docs.docker.com/registry/deploying/#configure-tls-on-a-registry-server"&gt;Configure TLS on a registry server&lt;/a&gt;，以及&lt;a href="https://docs.docker.com/registry/configuration/#auth"&gt;Registry Configuration Reference&lt;/a&gt;。但是还是有一些场景是不需要安全证书以及安全认证的，关于如何绕过这些安全配置，我就没有找到一个很好的教程了。下面就是我自己摸索出来的配置方式，总得来说就是我们要在执行Pull和Push的地方配置好&lt;code&gt;insecure-registry&lt;/code&gt;这个参数：&lt;/p&gt;

&lt;h4&gt;对于开发环境（Windows，OSX）&lt;/h4&gt;

&lt;p&gt;一般我们都使用了boot2docker，所以这里是基于boot2docker的配置。&lt;/p&gt;

&lt;p&gt;进入到运行Docker的虚拟机中&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ boot2docker ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改Docker启动配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ sudo vi /var/lib/boot2docker/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加配置&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;DOCKER_OPTS=&amp;ldquo;&amp;ndash;insecure-registry 120.0.0.1:5000&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里的&lt;code&gt;120.0.0.1:5000&lt;/code&gt;就是你的Registry所在服务器的IP和端口号。如果你需要向多个Registry Push，或者从多个Registry Pull，那么你可以添加多个&lt;code&gt;insecure-registry&lt;/code&gt;，例如：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;DOCKER_OPTS=&amp;ldquo;&amp;ndash;insecure-registry 120.0.0.1:5000 &amp;ndash;insecure-registry 120.0.0.2:5000&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;退出Docker虚拟机后重启Docker&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ boot2docker restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在终于可以在本地环境build镜像，然后往我们搭建起来的Registry Push了。&lt;/p&gt;

&lt;h4&gt;对于生产环境（Ubuntu，CentOS）&lt;/h4&gt;

&lt;p&gt;跟开发环境差别不大，目的都是一样的，只是手段不同。&lt;/p&gt;

&lt;p&gt;ssh到我们需要部署镜像的生产服务器上，修改Docker启动配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ sudo vi /etc/default/docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加配置&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;DOCKER_OPTS=&amp;ldquo;&amp;ndash;insecure-registry 120.0.0.1:5000&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;重启Docker&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ service docker restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以在生产服务器上Pull放在我们私有Registry中的Image了。&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;到这里整个配置就完成了，我感觉最坑爹的地方在于，这个&lt;code&gt;insecure-registry&lt;/code&gt;的配置其实是针对Pull这个操作的，但是Push也需要这个配置，而且这个配置在Push/Pull的时候不能指定，必须在启动Docker的时候指定，每次改了还得重启Docker……社区对于这个丧病的行为已经诸多意见了，例如这个issue：&lt;a href="https://github.com/docker/docker/issues/8887"&gt;&amp;ndash;insecure-registry should be on &amp;ldquo;docker pull&amp;rdquo;&lt;/a&gt;，但是目前为止Docker还没有修改。甚至有人还在这个issue里面贴出了更加丧病的work around，就是使用ssh tunnel：&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ docker pull host:5000/image #fails
$ ssh -N -L 5000:host:5000 user@host
$ docker pull localhost:5000/image #works
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;希望Docker的后续版本可以更加方便的向私有Registry Pull和Push，或者是有更加方便的配置安全证书和安全认证的方式。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>聊一聊基于Flux的前端系统——基础架构以及演进</title>
    <link rel="alternate" href="/2015/04/09/basic_architecture_and_evolution_for_a_flux_front_end_system.html"/>
    <id>/2015/04/09/basic_architecture_and_evolution_for_a_flux_front_end_system.html</id>
    <published>2015-04-09T14:46:00Z</published>
    <updated>2015-04-09T14:46:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;在最近的一个项目中，我们团队尝试了Flux + React.js的架构，在这种架构中我们获得了很多的好处：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据流更加清晰和简单，使得我们的开发和debug也可以按照一个清晰和标准的方式进行；&lt;/li&gt;
&lt;li&gt;数据处理这一层的职责更加清晰，使得我们可以更容易的进行数据维护、缓存的处理；&lt;/li&gt;
&lt;li&gt;在界面的处理上只用关心界面的最终状态，不需要维护中间过程；&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们就来聊一聊我们团队在这种架构中的一些实践，希望可以对大家有用。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;在最近的一个项目中，我们团队尝试了Flux + React.js的架构，在这种架构中我们获得了很多的好处：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据流更加清晰和简单，使得我们的开发和debug也可以按照一个清晰和标准的方式进行；&lt;/li&gt;
&lt;li&gt;数据处理这一层的职责更加清晰，使得我们可以更容易的进行数据维护、缓存的处理；&lt;/li&gt;
&lt;li&gt;在界面的处理上只用关心界面的最终状态，不需要维护中间过程；&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们就来聊一聊我们团队在这种架构中的一些实践，希望可以对大家有用。&lt;/p&gt;

&lt;h3&gt;基础架构以及Why&lt;/h3&gt;

&lt;p&gt;在这个项目中我们采用的基础架构是reflux.js + react.js + 一些小的library，例如：director.js，jquery.js，lodash.js。&lt;/p&gt;

&lt;h4&gt;reflux.js&lt;/h4&gt;

&lt;p&gt;选用reflux.js作为Flux的实现，是因为现在reflux.js是Github上最受欢迎的一个实现，并且提供了非常实际的便捷。它和Facebook Flux主要的不同在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有了dispatcher这一层，actions直接是listenable的；&lt;/li&gt;
&lt;li&gt;stores可以直接listen actions，而不需要用swtich去区分一大堆Action types；&lt;/li&gt;
&lt;li&gt;stores提供了很多方便的方法使得view可以很方便的监听；&lt;/li&gt;
&lt;li&gt;提供了一种比较好的思路来处理API请求这种异步actions。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var Reflux = require(&amp;#39;reflux&amp;#39;);
var React = require(&amp;#39;react&amp;#39;);

var UserAction = Reflux.createAction({
    &amp;#39;login&amp;#39;: {children: [&amp;#39;success&amp;#39;, &amp;#39;failed&amp;#39;]}
});

UsersAction.login.listen(function(data) {
    $.post(&amp;#39;/api/users/Action/login&amp;#39;, data).then(this.success, this.failed);
});

var UserStore = Reflux.createStore({
    listenables: UserAction,
    onLoginSuccess: function(payload) {
        this.trigger(payload);
    },
    onLoginFailed: function(payload) {
        this.trigger(payload);
    }
});

var UserComponent = React.createClass({
    mixins: [Reflux.connect(UserStore, &amp;#39;user&amp;#39;)],
    render: function() {
        return &amp;lt;span&amp;gt;{this.state.user.name}&amp;lt;/span&amp;gt;;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我看来最大的好处就是，少写了很多代码，并且代码的可读性还挺好的。&lt;/p&gt;

&lt;h4&gt;libraries&lt;/h4&gt;

&lt;p&gt;在这个项目中我们选用了很多小而专的library，而不是选用一个大而全的framework（例如：Angular.js，Ember.js），是因为选用那样的framework风险比较大，替换成本很高，一旦出现了像Angular.js 2.0这样的升级，对团队来说比较痛苦。而选用小library的集合，要替换其中某一部分是很容易的。并且不会被framework的principle和DSL所绑架，比较好行程适用于自己项目domain的principle和DSL。&lt;/p&gt;

&lt;p&gt;下面来介绍一下我们用到的libraries：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;director.js是一个Server端和Client端通用的router工具。&lt;/li&gt;
&lt;li&gt;jquery.js就不用介绍了。选这个主要是用来做来项目中的Ajax call、promise工具，原因也是被逼无奈，我们用到的很多插件都基于它，为了不增加额外的加载量，也就只有将就用它了。&lt;/li&gt;
&lt;li&gt;lodash.js这个也不用介绍了，比underscore.js性能更高，功能更强。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;架构的演进&lt;/h3&gt;

&lt;p&gt;前面介绍了我们项目的基础架构，由于我们是用了各种小library，并且都是我们自己选的，那么就没有一个现成的架构来告诉我们这样架构的最佳实践是什么，一切都需要我们自己去探索和演进。下面我就来介绍一下项目各个部分的演进路线是什么样的，以及为什么会出现这样的演进。&lt;/p&gt;

&lt;h4&gt;页面render的lifecircle&lt;/h4&gt;

&lt;p&gt;项目开始时是非常简单的render方式，就是当route改变时，router根据最新的route去选择某个component render到页面中：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var Router = require(&amp;#39;director&amp;#39;).Router;
var $ = require(&amp;#39;jquery&amp;#39;);

var router = new Router({
    &amp;#39;/login&amp;#39;: function() {
        React.render(React.createElement(LoginComponent), $(&amp;#39;.container&amp;#39;).get(0));
    }
}).configure();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我发现在很多时候我需要在程序中去控制页面跳转，例如：登录成功以后跳转到首页。于是我就在登录后用 &lt;code&gt;window.location.hash = &amp;#39;/&amp;#39;&lt;/code&gt; 去做跳转。后来我发现程序中到处都是 &lt;code&gt;window.location.hash = &amp;#39;xxx&amp;#39;&lt;/code&gt;，到处修改这种全局变量不是一个好的实践，并且这样在未来做isomophic也会很难。于是我决定用Flux的方式来处理这一部分逻辑。很显然，这里的Store存储的是当前的route，Action所触发的是route的改变，于是我们增加了RouteStore和RouteAction：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var RouteAction = Reflux.createAction([&amp;#39;navigateTo&amp;#39;]);

var RouteStore = Reflux.createStore({
    listenables: RouteActions,

    onNavigateTo: function(newRoute) {
        this.trigger(newRoute);
    }
});

RouteStore.listen(function(newRoute) {
  router.setRoute(newRoute);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样所有的 &lt;code&gt;window.location.hash = &amp;#39;xxx&amp;#39;&lt;/code&gt; 都被替换成了 &lt;code&gt;RouteAction.navigateTo(&amp;#39;xxx&amp;#39;)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;后来当页面增加，我发现在route配置中出现了很多重复的代码，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var router = new Router({
    &amp;#39;/login&amp;#39;: function() {
        React.render(React.createElement(HeaderComponent), $(&amp;#39;.header&amp;#39;).get(0));
        React.render(React.createElement(LoginComponent), $(&amp;#39;.container&amp;#39;).get(0));
    },
    &amp;#39;/register&amp;#39;: function() {
        React.render(React.createElement(HeaderComponent), $(&amp;#39;.header&amp;#39;).get(0));
        React.render(React.createElement(RegisterComponent), $(&amp;#39;.container&amp;#39;).get(0));
    },
    &amp;#39;/profile&amp;#39;: function() {
        React.render(React.createElement(HeaderComponent), $(&amp;#39;.header&amp;#39;).get(0));
        React.render(React.createElement(ProfileComponent), $(&amp;#39;.container&amp;#39;).get(0));
    }
}).configure();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，我希望把这种layout和page的render也用Flux的方式来进行管理。那么这里Store所存储的就是页面的component，Action所触发的就是页面component的改变，于是我增加了PageStore和PageAction，同时把各种layout放到PageComponent中管理：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var PageAction = Reflux.createAction([&amp;#39;render&amp;#39;]);

var PageStore = Reflux.createStore({
    listenables: PageActions,

    onRender: function(component, props) {
        this.trigger({
            component: component,
            props: props
        });
    }
});

var PageComponent = React.createClass({
    mixins: [Reflux.connect(PageStore, &amp;#39;page&amp;#39;)],

    render: function() {
        return (
            &amp;lt;div&amp;gt;
                &amp;lt;HeaderComponent /&amp;gt;
                &amp;lt;PageComponent {...this.state.page.props} /&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们route的配置就可以很简单了：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var router = new Router({
    &amp;#39;/login&amp;#39;: function() {
        PageAction.render(LoginComponent);
    },
    &amp;#39;/register&amp;#39;: function() {
        PageAction.render(RegisterComponent);
    },
    &amp;#39;/profile&amp;#39;: function() {
        PageAction.render(ProfileComponent);
    }
}).configure();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最近我们还加上了一个需求，就是对于profile页面，只能让登录的用户进入，对于这种需求在这种架构下就很好添加了，只需要修改PageAction:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var PageAction = Reflux.createAction([&amp;#39;render&amp;#39;, &amp;#39;renderIfLogin&amp;#39;]);

PageAction.renderIfLogin.preEmit = function(component, props) {
    if (userIsLogin) {
        PageAction.render(component, props);
    } else {
        RouteAction.navigateTo(&amp;#39;/login&amp;#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在profile页面，我们调用&lt;code&gt;PageAction.renderIfLogin(ProfileComponent)&lt;/code&gt;这样如果用户没有登录，就会被自动跳转到登录页面。&lt;/p&gt;

&lt;p&gt;现在我们来总结一下当前的页面render lifecircle：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    URL  ===trigger===&amp;gt;  Router  ===call===&amp;gt; PageAction.render 
     /\                                            ||
     ||                                          trigger         
  tirgger                                          ||
     ||                                            \/
    界面 &amp;lt;==render== PageComponent &amp;lt;==trigger== PageStore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个就是一个基于事件的单向数据流了！&lt;/p&gt;

&lt;h4&gt;Store与Action&lt;/h4&gt;

&lt;p&gt;这里用UsersStore和UsersAction作为示例。其实最开始的时候，它们是UserStore以及UserAction，因为系统中最开始只需要记录和操作当前登录的user：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var UserAction = Reflux.createAction({
    asyncResult: true,
    children: [&amp;#39;login&amp;#39;, &amp;#39;register&amp;#39;]
});

UserAction.login.listen(function(data) {
    $.post(&amp;#39;/api/users/Action/login&amp;#39;, data).then(this.loginCompleted);
});

UserAction.register.listen(function(data) {
    $.post(&amp;#39;/api/users&amp;#39;, data).then(this.registerCompleted);
});

var UserStore = Reflux.createStore({
    listenables: UserAction,
    onLoginCompleted: function(payload) {
        this.trigger(payload);
    },
    onRegisterCompleted: function(payload) {
        this.trigger(payload);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当时的UserStore非常简单，没有任何逻辑，只是把API返回的数据trigger给View就完了。但是当我们增加了显示当前所有user list的需求，我们就必须又增加一个UsersStore和UsersAction：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var UsersAction = Reflux.createAction({
    asyncResult: true,
    children: [&amp;#39;fetch&amp;#39;]
});

UsersAction.fetch.listen(function(data) {
    $.get(&amp;#39;/api/users&amp;#39;, data).then(this.fetchCompleted);
});

var UsersStore = Reflux.createStore({
    listenables: UsersAction,
    onFetchCompleted: function(payload) {
        this.trigger(payload);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果只是简单的这么写，就会有一个陷阱，因为UsersStore其实是包含了UserStore的，也就是说当前user的数据需要在两个地方维护；并且同样一个Domain，被分成了两个Action + 两个Store，也非常奇怪。基于以上两点，我决定针对同一个Domain，只会有一个Action和一个Store与之对应，这样概念上更好理解，并且不会出样同一份数据，要在两处维护的麻烦。于是UserAction和UserStore就被合并到了UsersAction和UsersStore中：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var UsersAction = Reflux.createAction({
    asyncResult: true,
    children: [&amp;#39;fetchAll&amp;#39;, &amp;#39;login&amp;#39;, &amp;#39;register&amp;#39;]
});

UsersAction.fetchAll.listen(function(data) {
    $.get(&amp;#39;/api/users&amp;#39;, data).then(this.fetchCompleted);
});

UsersAction.login.listen(function(data) {
    $.post(&amp;#39;/api/users/Action/login&amp;#39;, data).then(this.loginCompleted);
});

UsersAction.register.listen(function(data) {
    $.post(&amp;#39;/api/users&amp;#39;, data).then(this.registerCompleted);
});

var users = [];
var UsersStore = Reflux.createStore({
    listenables: UsersAction,
    onFetchAllCompleted: function(payload) {
        users = payload;
        this.trigger(users);
    },
    onLoginCompleted: function(payload) {
        var index = users.findIndx({id: payload.id});
        if (index &amp;lt; 0) {
            users.push(payload);
        } else {
            users[index] = payload;
        }
        this.trigger(users);
    },
    onRegisterCompleted: function(payload) {
        users.push(payload);
        this.trigger(users);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的架构我们使用了很长一段时间，但是当Domain的数量增加以后，我们发现每个Store做的事情其实都一样：把API返回的数据，根据ID merge进他自己的list里面。对于这种重复性很高，通用性有很强的逻辑，我们把它抽出来做成了一个Node Package，叫做&lt;a href="https://github.com/zation/traction"&gt;traction&lt;/a&gt;。它可以根据一个指定的key，将两个数据进行merge，可以是从Object到Array，也可以是Array到Array，具体说明可以参考它的README。&lt;/p&gt;

&lt;p&gt;于是我们的Store代码就可以进一步简化为：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var traction = require(&amp;#39;traction&amp;#39;);

var users = [];
var UsersStore = Reflux.createStore({
    listenables: UsersAction,
    onFetchAllCompleted: function(payload) {
        users = traction.merge(payload).to(users).basedOn(&amp;#39;id&amp;#39;);
        this.trigger(users);
    },
    onLoginCompleted: function(payload) {
        users = traction.merge(payload).to(users).basedOn(&amp;#39;id&amp;#39;);
        this.trigger(users);
    },
    onRegisterCompleted: function(payload) {
        users = traction.merge(payload).to(users).basedOn(&amp;#39;id&amp;#39;);
        this.trigger(users);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们发现其实Store里面监听不同的Action所做的事情都是一样的，那么我们可以进一步简化：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var UsersAction = Reflux.createAction([&amp;#39;fetchAll&amp;#39;, &amp;#39;login&amp;#39;, &amp;#39;register&amp;#39;, &amp;#39;save&amp;#39;]);

UsersAction.fetchAll.listen(function(data) {
    $.get(&amp;#39;/api/users&amp;#39;, data).then(this.save);
});

UsersAction.login.listen(function(data) {
    $.post(&amp;#39;/api/users/Action/login&amp;#39;, data).then(this.save);
});

UsersAction.register.listen(function(data) {
    $.post(&amp;#39;/api/users&amp;#39;, data).then(this.save);
});

var users = [];
var UsersStore = Reflux.createStore({
    listenables: UsersAction,
    onSave: function(payload) {
        users = traction.merge(payload).to(users).basedOn(&amp;#39;id&amp;#39;);
        this.trigger(users);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们又遇到新的问题了，就是在很多地方我要拿到当前的user，而在上面那样统一处理以后我就没有办法拿到了。针对这个问题有两种解决方案：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;添加一个CurrentUserStore，要那当前user，就可以监听这个Store。但是这样就会又导致同一份数据在两个地方维护的问题，所以这并不是一个推荐的解决方案。&lt;/li&gt;
&lt;li&gt;在UsersStore中，针对当前user的那一条数据添加一个flag，例如：isLogin，然后我在其他地方就可以使用 &lt;code&gt;users.find(&amp;#39;isLogin&amp;#39;)&lt;/code&gt; 来拿到当前登录的那个user了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要使用第二个解决方案，我们需要对login的action和UsersStore都进行一些改造，下面是一个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;UsersAction.login.listen(function(data) {
    $.post(&amp;#39;/api/users/Action/login&amp;#39;, data).then(function(data) {
        this.save(data, true);
    });
});

var users = [];
var UsersStore = Reflux.createStore({
    listenables: UsersAction,
    onSave: function(payload, isLogin) {
        if (isLogin) {
            payload.isLogin = true;
        }
        users = traction.merge(payload).to(users).basedOn(&amp;#39;id&amp;#39;);
        this.trigger(users);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到这里好像还少了点什么？对，就是错误处理。很多时候我们需要显示Server端的错误，或者是当401的时候跳转到登录页面。针对这个我们的处理方式是有一个全局的ExceptionAction和ExceptionStore：&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;var ExceptionAction = Reflux.createAction([&amp;#39;serverError&amp;#39;]);

ExceptionAction.serverError.preEmit = function(error) {
    if (error.status === 401) {
        RouteActions.navigateTo(&amp;#39;/login&amp;#39;);
    }
}

var ExceptionStore = Reflux.createStore({
    listenables: ExceptionActions,

    onServerError: function(payload) {
        this.trigger(payload);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要显示Server端错误信息的Component就可以监听ExceptionStore了。&lt;/p&gt;

&lt;p&gt;到这里为之就是我们Action和Store的当前形态了。其实现在可以看出来，当merge数据的逻辑被抽出来以后，Store就是一个缓存了，后面要做的一件事情可能就是，Action需要根据Store的状态来决定到底是从API去读数据，还是从某个Client缓存（例如：LocalStorage）读数据。&lt;/p&gt;

&lt;p&gt;最后我们来总结一下关于Action和Store的一些最佳实践：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不要在Action做任何针对数据的逻辑处理，把最纯粹的数据交给Store来处理；&lt;/li&gt;
&lt;li&gt;针对同一个Domain只能有一个Store与之对应，对Action同理；&lt;/li&gt;
&lt;li&gt;Store在维护自身数据的时候需要考虑到很多情况，例如：单个数据的添加/修改、多个数据的添加/修改。推荐使用&lt;a href="https://github.com/zation/traction"&gt;traction&lt;/a&gt;来进行处理；&lt;/li&gt;
&lt;li&gt;对于Store中需要特殊存储的数据，建议使用一个flag来标识，而不是再增加一个Store。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;遗留的一些问题&lt;/h3&gt;

&lt;h4&gt;重复的数据请求&lt;/h4&gt;

&lt;p&gt;由于我们现在项目中，fetchAction的触发都是由需要那个数据的Component自己触发的，这样就有可能导致一个页面中重复发出同一个请求。例如：每个页面都会有一个header，header中会显示用户名，那么header就会去调用 &lt;code&gt;UsersAction.fetchCurrent&lt;/code&gt;；在profile页面，显示profile信息的component肯定也需要user信息，那么他也会去调用 &lt;code&gt;UsersAction.fetchCurrent&lt;/code&gt;。这样在profile页面就会有两个同样的请求发出。&lt;/p&gt;

&lt;h4&gt;如何做数据缓存？&lt;/h4&gt;

&lt;p&gt;对于数据缓存我们已经有了一些方向，例如：对于缓存的操作，是由Store来进行；对于是从缓存来读取数据，还是从API读取数据，是由Action来决定。但问题是如果要由Action来决定，那么Action又需要知道Store的状态，现在能想到的方法就是Store上有个 &lt;code&gt;getData&lt;/code&gt; 的接口让Action来获取数据，然后Action就可以做判断了。不过我们希望可以有更好的方式，也许Action可以不用持有Store就可以完成这个判断？&lt;/p&gt;

&lt;p&gt;大家对于这两个问题有什么看法，欢迎大家在评论中与我讨论，也欢迎来信讨论，我的电子邮件是 &lt;a href="mailto:zation1@gmail.com"&gt;zation1@gmail.com&lt;/a&gt;。谢谢！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>用React.js替换Backbone.js的View（二）——Todo MVC示例</title>
    <link rel="alternate" href="/2015/01/15/replace_backbonejs_view_with_reactj_2.html"/>
    <id>/2015/01/15/replace_backbonejs_view_with_reactj_2.html</id>
    <published>2015-01-15T23:54:00Z</published>
    <updated>2015-01-15T23:54:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;Backbone.js和React.js在设计思想上都借鉴了&lt;a href="http://en.wikipedia.org/wiki/Reactive_programming"&gt;Reactive Programming&lt;/a&gt;，即：当Model修改时，这种变更可以反向传播到View，使得View同时被更改，也就是双向绑定。但Backbone.js需要你自己来写如何修改View，而在React.js中，你只需要关心如何根据Model来显示View，如何修改可以完全交给React.js。也就是说他们都在做一种简化，而React.js做的更加彻底，这也是它的核心思想和优点。&lt;/p&gt;

&lt;p&gt;真正的学习还是需要写代码，所以这里用经典的&lt;a href="https://github.com/tastejs/todomvc"&gt;Todo MVC&lt;/a&gt;作为示例。所有的代码可以在我的&lt;a href="https://github.com/zation/backbone-to-react"&gt;Github&lt;/a&gt;上找到。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;Backbone.js和React.js在设计思想上都借鉴了&lt;a href="http://en.wikipedia.org/wiki/Reactive_programming"&gt;Reactive Programming&lt;/a&gt;，即：当Model修改时，这种变更可以反向传播到View，使得View同时被更改，也就是双向绑定。但Backbone.js需要你自己来写如何修改View，而在React.js中，你只需要关心如何根据Model来显示View，如何修改可以完全交给React.js。也就是说他们都在做一种简化，而React.js做的更加彻底，这也是它的核心思想和优点。&lt;/p&gt;

&lt;p&gt;真正的学习还是需要写代码，所以这里用经典的&lt;a href="https://github.com/tastejs/todomvc"&gt;Todo MVC&lt;/a&gt;作为示例。所有的代码可以在我的&lt;a href="https://github.com/zation/backbone-to-react"&gt;Github&lt;/a&gt;上找到。&lt;/p&gt;

&lt;h3&gt;环境准备&lt;/h3&gt;

&lt;p&gt;React.js推荐使用&lt;a href="http://facebook.github.io/react/docs/displaying-data.html"&gt;JSX&lt;/a&gt;来写View，所以我们需要准备一下JSX的环境。按照最简单的做法，我们只需要将in-browser JSX transformer引入即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ bower install --save react
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;index.html&lt;/code&gt;中，加入一下的代码，作为script标签的第一个：&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;script src=&amp;quot;bower_components/react/react-with-addons.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;bower_components/react/JSXTransformer.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们的JSX代码就可以在运行时编译了。&lt;/p&gt;

&lt;h3&gt;替换的方式&lt;/h3&gt;

&lt;p&gt;这里我们实际上是做的一个重构（虽然没有测试），为了尽量使得每一步都比较容易验证，我们每次commit的修改都会尽量很小，而且每次commit的代码都要保证是工作的，不会破坏原有的功能。所以我们会在原有的代码的基础上增加React.js的代码，完成一部分再删除一部分Backbone.js View的代码，最后再完成整个替换。&lt;/p&gt;

&lt;p&gt;一般来说我推荐先替换Template，再替换DOM事件的绑定和处理，最后再整体用某个Component替换掉Backbone.js View。下面我会用TodoItem View替换过程的开始部分作为示例，讲解一下如何重构，同时也讲解一些React.js的基本概念。&lt;/p&gt;

&lt;h3&gt;Template&lt;/h3&gt;

&lt;p&gt;我们之前提到过，React.js的Component其实就是View + Template的结合。那么我们应该怎样来划分Component呢？这里React.js官方给出的意见是：遵从&lt;a href="http://en.wikipedia.org/wiki/Single_responsibility_principle"&gt;单一职责的原则&lt;/a&gt;，也就是一个Component只做一件事。具体如何划分就要看你的Domain和团队自己的规则了。&lt;/p&gt;

&lt;p&gt;现在我们新建TodoItem Component，新建&lt;code&gt;todo-item.jsx&lt;/code&gt;文件，将原来template中的内容挪过来，并且用React.js的方式来render：&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;var app = app || {};

(function () {
    &amp;#39;use strict&amp;#39;;

    app.TodoItem = React.createClass({

        render: function() {
            var todoData = this.props.todo.toJSON();
            return (
                &amp;lt;div&amp;gt;
                    &amp;lt;div className=&amp;quot;view&amp;quot;&amp;gt;
                        &amp;lt;input className=&amp;quot;toggle&amp;quot; type=&amp;quot;checkbox&amp;quot; checked={todoData.completed} /&amp;gt;
                        &amp;lt;label&amp;gt;{todoData.title}&amp;lt;/label&amp;gt;
                        &amp;lt;button className=&amp;quot;destroy&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;input className=&amp;quot;edit&amp;quot; defaultValue={todoData.title} /&amp;gt;
                &amp;lt;/div&amp;gt;
            );
        }
    });
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换&lt;code&gt;todo-view.js&lt;/code&gt;中的template：&lt;/p&gt;

&lt;pre&gt;&lt;code class="diff"&gt;@@ -12,9 +12,6 @@
                //... is a list tag.
                tagName:  &amp;#39;li&amp;#39;,

-               // Cache the template function for a single item.
-               template: _.template($(&amp;#39;#item-template&amp;#39;).html()),
-
                // The DOM events specific to an item.
                events: {
                        &amp;#39;click .toggle&amp;#39;: &amp;#39;toggleCompleted&amp;#39;,
@@ -48,7 +45,9 @@
                                return;
                        }

-                       this.$el.html(this.template(this.model.toJSON()));
+                       React.render(React.createElement(app.TodoItem, {
+                               todo: this.model
+                       }), this.$el[0]);
                        this.$el.toggleClass(&amp;#39;completed&amp;#39;, this.model.get(&amp;#39;completed&amp;#39;));
                        this.toggleVisible();
                        this.$input = this.$(&amp;#39;.edit&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们用到了React.js Component的&lt;code&gt;props&lt;/code&gt;属性，这个属性是由父Component传下来的数据，&lt;code&gt;props&lt;/code&gt;本身是不可以由子Component自己去改变的，后面我们会讲到，对用户操作会改变的数据，应该使用&lt;code&gt;state&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;index.html&lt;/code&gt;中删除原有的模板，引入&lt;code&gt;todo-item.jsx&lt;/code&gt;，同时用JSXTransformer来管理所有View的加载：&lt;/p&gt;

&lt;pre&gt;&lt;code class="diff"&gt;@@ -23,16 +23,6 @@
            &amp;lt;p&amp;gt;Written by &amp;lt;a href=&amp;quot;https://github.com/addyosmani&amp;quot;&amp;gt;Addy Osmani&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;Part of &amp;lt;a href=&amp;quot;http://todomvc.com&amp;quot;&amp;gt;TodoMVC&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;/footer&amp;gt;
-       &amp;lt;script type=&amp;quot;text/template&amp;quot; id=&amp;quot;item-template&amp;quot;&amp;gt;
-           &amp;lt;div&amp;gt;
-               &amp;lt;div class=&amp;quot;view&amp;quot;&amp;gt;
-                   &amp;lt;input class=&amp;quot;toggle&amp;quot; type=&amp;quot;checkbox&amp;quot; &amp;lt;%= completed ? &amp;#39;checked&amp;#39; : &amp;#39;&amp;#39; %&amp;gt;&amp;gt;
-                   &amp;lt;label&amp;gt;&amp;lt;%- title %&amp;gt;&amp;lt;/label&amp;gt;
-                   &amp;lt;button class=&amp;quot;destroy&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
-               &amp;lt;/div&amp;gt;
-               &amp;lt;input class=&amp;quot;edit&amp;quot; value=&amp;quot;&amp;lt;%- title %&amp;gt;&amp;quot;&amp;gt;
-           &amp;lt;/div&amp;gt;
-       &amp;lt;/script&amp;gt;
        &amp;lt;script type=&amp;quot;text/template&amp;quot; id=&amp;quot;stats-template&amp;quot;&amp;gt;
            &amp;lt;span id=&amp;quot;todo-count&amp;quot;&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;%= remaining %&amp;gt;&amp;lt;/strong&amp;gt; &amp;lt;%= remaining === 1 ? &amp;#39;item&amp;#39; : &amp;#39;items&amp;#39; %&amp;gt; left&amp;lt;/span&amp;gt;
            &amp;lt;ul id=&amp;quot;filters&amp;quot;&amp;gt;

@@ -52,16 +42,16 @@
        &amp;lt;script src=&amp;quot;js/models/todo.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src=&amp;quot;js/collections/todos.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
-       &amp;lt;script src=&amp;quot;js/views/todo-view.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
-       &amp;lt;script src=&amp;quot;js/views/app-view.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
-       &amp;lt;script src=&amp;quot;js/routers/router.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
-       &amp;lt;script src=&amp;quot;js/app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
+       &amp;lt;script type=&amp;quot;text/jsx&amp;quot; src=&amp;quot;js/components/todo-item.jsx&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
+       &amp;lt;script type=&amp;quot;text/jsx&amp;quot; src=&amp;quot;js/views/todo-view.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
+       &amp;lt;script type=&amp;quot;text/jsx&amp;quot; src=&amp;quot;js/views/app-view.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
+       &amp;lt;script type=&amp;quot;text/jsx&amp;quot; src=&amp;quot;js/routers/router.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
+       &amp;lt;script type=&amp;quot;text/jsx&amp;quot; src=&amp;quot;js/app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
 &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里，替换就告一段落了。这个时候我们可以看到原有的功能都是可工作的，现在就可以做一个提交了。&lt;/p&gt;

&lt;h3&gt;DOM事件&lt;/h3&gt;

&lt;p&gt;下面我们开始把DOM事件的处理挪到&lt;code&gt;todo-item.jsx&lt;/code&gt;中，并且以React.js的方式来做。以toggle为例：&lt;/p&gt;

&lt;pre&gt;&lt;code class="diff"&gt;index js/components/todo-item.jsx
@@ -5,12 +5,28 @@
    app.TodoItem = React.createClass({

+       getInitialState: function() {
+           return {
+               completed: this.props.todo.get(&amp;#39;completed&amp;#39;)
+           };
+       },
+
+       // Toggle the `&amp;quot;completed&amp;quot;` state of the model.
+       toggleCompleted: function () {
+           this.setState({
+               completed: this.props.todo.toggle()
+           });
+       },
+
        render: function() {
            var todoData = this.props.todo.toJSON();
            return (
                &amp;lt;div&amp;gt;
                    &amp;lt;div className=&amp;quot;view&amp;quot;&amp;gt;
-                       &amp;lt;input className=&amp;quot;toggle&amp;quot; type=&amp;quot;checkbox&amp;quot; checked={todoData.completed} /&amp;gt;
+                       &amp;lt;input className=&amp;quot;toggle&amp;quot;
+                           type=&amp;quot;checkbox&amp;quot;
+                           checked={this.state.completed}
+                           onChange={this.toggleCompleted}/&amp;gt;
                        &amp;lt;label&amp;gt;{todoData.title}&amp;lt;/label&amp;gt;
                        &amp;lt;button className=&amp;quot;destroy&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
                    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="diff"&gt;index js/models/todo.js
@@ -18,9 +18,11 @@
        // Toggle the `completed` state of this todo item.
        toggle: function () {
+           var completed = !this.get(&amp;#39;completed&amp;#39;);
            this.save({
-               completed: !this.get(&amp;#39;completed&amp;#39;)
+               completed: completed
            });
+           return completed;
        }
    });
 })();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="diff"&gt;index js/views/todo-view.js
@@ -14,7 +14,6 @@
        // The DOM events specific to an item.
        events: {
-           &amp;#39;click .toggle&amp;#39;: &amp;#39;toggleCompleted&amp;#39;,
            &amp;#39;dblclick label&amp;#39;: &amp;#39;edit&amp;#39;,
            &amp;#39;click .destroy&amp;#39;: &amp;#39;clear&amp;#39;,
            &amp;#39;keypress .edit&amp;#39;: &amp;#39;updateOnEnter&amp;#39;,
@@ -64,11 +63,6 @@
                app.TodoFilter === &amp;#39;completed&amp;#39;;
        },

-       // Toggle the `&amp;quot;completed&amp;quot;` state of the model.
-       toggleCompleted: function () {
-           this.model.toggle();
-       },
-
        // Switch this view into `&amp;quot;editing&amp;quot;` mode, displaying the input field.
        edit: function () {
            this.$el.addClass(&amp;#39;editing&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里toggle事件就被重构完成了。我们引入了一个新的概念，就是&lt;code&gt;state&lt;/code&gt;。我们之前提到过，&lt;code&gt;state&lt;/code&gt;是用来表示Component中，用户通过操作可能改变的数据。关于&lt;code&gt;state&lt;/code&gt;和&lt;code&gt;props&lt;/code&gt;的详细区别，这里有一篇文章（&lt;a href="https://github.com/uberVU/react-guide/blob/master/props-vs-state.md"&gt;props vs state&lt;/a&gt;）介绍得很好，这里把最关键的部分转载并翻译一下：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;&lt;em&gt;props&lt;/em&gt;&lt;/th&gt;
&lt;th&gt;&lt;em&gt;state&lt;/em&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;能否从&lt;strong&gt;父&lt;/strong&gt;Component获取初始值?&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;父&lt;/strong&gt;Component中的值改变，是否会影响自身的值?&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;能否在自身中设置默认值?^&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;能否在自身中改变值?&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;能否给子Component设置默认值?&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自身的值改变，是否会影响传给子Component中的值?&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;^ 注意：props和state的默认值，都会被父Component传过来的默认值覆盖。&lt;/p&gt;

&lt;h3&gt;DOM操作&lt;/h3&gt;

&lt;p&gt;在View这一层，我们常常会有针对某个Element进行操作的需求，以前我们可能会通过Class、ID或Tag来获取到这个Element，然后调用DOM方法来操作它。而React.js提供了&lt;code&gt;refs&lt;/code&gt;来完成这个功能：&lt;/p&gt;

&lt;pre&gt;&lt;code class="diff"&gt;index js/components/todo-item.jsx
@@ -18,6 +18,11 @@
            });
        },

+       // Switch this view into `&amp;quot;editing&amp;quot;` mode, displaying the input field.
+       edit: function () {
+           this.refs.editInput.getDOMNode().focus();
+       },
+
        render: function() {
            var todoData = this.props.todo.toJSON();
            return (
@@ -27,10 +32,10 @@
                            type=&amp;quot;checkbox&amp;quot;
                            checked={this.state.completed}
                            onChange={this.toggleCompleted}/&amp;gt;
-                       &amp;lt;label&amp;gt;{todoData.title}&amp;lt;/label&amp;gt;
+                       &amp;lt;label onDoubleClick={this.edit}&amp;gt;{todoData.title}&amp;lt;/label&amp;gt;
                        &amp;lt;button className=&amp;quot;destroy&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
                    &amp;lt;/div&amp;gt;
-                   &amp;lt;input className=&amp;quot;edit&amp;quot; defaultValue={todoData.title} /&amp;gt;
+                   &amp;lt;input ref=&amp;quot;editInput&amp;quot; className=&amp;quot;edit&amp;quot; defaultValue={todoData.title} /&amp;gt;
                &amp;lt;/div&amp;gt;
            );
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="diff"&gt;index js/views/todo-view.js
@@ -66,7 +66,6 @@
        // Switch this view into `&amp;quot;editing&amp;quot;` mode, displaying the input field.
        edit: function () {
            this.$el.addClass(&amp;#39;editing&amp;#39;);
-           this.$input.focus();
        },

        // Close the `&amp;quot;editing&amp;quot;` mode, saving changes to the todo.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里之所以React.js专门提供了refs，而没有推荐使用传统方式，我觉得是因为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;避免多余的class或ID，这样我们可以将class只用于样式上，将ID只用于form中，让他们的使用更加符合原始的设计；&lt;/li&gt;
&lt;li&gt;refs返回的其实不单是DOM对象，而是一个称为“backing instance”的东西，这个我没有查到具体含义是什么，猜测应该是React.js中Virtual DOM中的实例。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;此间省略N步，我们得到了最后的&lt;a href="https://github.com/zation/backbone-to-react"&gt;重构成果&lt;/a&gt;，如果希望看中间过程的，可以查看中间的commit diff。&lt;/p&gt;

&lt;p&gt;在替换前后之间，我们可以比较一下监听事件的不同，首先来看看替换前我们监听了哪些事件：&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;//todo-view.js
...
initialize: function () {
    this.listenTo(this.model, &amp;#39;change&amp;#39;, this.render);
    this.listenTo(this.model, &amp;#39;destroy&amp;#39;, this.remove);
    this.listenTo(this.model, &amp;#39;visible&amp;#39;, this.toggleVisible);
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;//app-view.js
...
initialize: function () {
...
    this.listenTo(app.todos, &amp;#39;add&amp;#39;, this.addOne);
    this.listenTo(app.todos, &amp;#39;reset&amp;#39;, this.addAll);
    this.listenTo(app.todos, &amp;#39;change:completed&amp;#39;, this.filterOne);
    this.listenTo(app.todos, &amp;#39;filter&amp;#39;, this.filterAll);
    this.listenTo(app.todos, &amp;#39;all&amp;#39;, this.render);
...
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们可以全文搜索一下替换后的事件监听，只剩下一个：&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;//app.js
...
app.todos.on(&amp;#39;all&amp;#39;, render);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，不管数据如何变化，不管哪些数据变化了，我都直接拿我关心的数据来render就完了。由于Virtual DOM帮我做了增量式的DOM修改，这一部分就不用我来操心了，那么之前的一大堆事件监听以及相应的事件处理回调都可以省略了，这样代码逻辑的复杂度会降低很多，可维护和可读性会提高很多，同时也没有性能的担忧。React.js真是处理Tempate和View的一大神器啊！&lt;/p&gt;

&lt;p&gt;而且重构到最后我发现，如果不是因为Backbone.js的router依赖于jQuery，连jQuery我都可以直接删了。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>用React.js替换Backbone.js的View（一）——Backbone.js View的陷阱以及React.js的优点</title>
    <link rel="alternate" href="/2015/01/13/replace_backbonejs_view_with_reactj_1.html"/>
    <id>/2015/01/13/replace_backbonejs_view_with_reactj_1.html</id>
    <published>2015-01-13T14:25:00Z</published>
    <updated>2015-01-13T14:25:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;最近终于找到时间，学习了一下Facebook出品的&lt;a href="http://facebook.github.io/react/"&gt;React.js&lt;/a&gt;，发现虽然没有很深的体会到性能上的好处，但是这种编程方式带来的好处确实是很大的。这里我准备跟Backbone.js的View做一下对比，同时下一篇文章中提供一个示例说明一下如何用React.js替换Backbone.js的View。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;最近终于找到时间，学习了一下Facebook出品的&lt;a href="http://facebook.github.io/react/"&gt;React.js&lt;/a&gt;，发现虽然没有很深的体会到性能上的好处，但是这种编程方式带来的好处确实是很大的。这里我准备跟Backbone.js的View做一下对比，同时下一篇文章中提供一个示例说明一下如何用React.js替换Backbone.js的View。&lt;/p&gt;

&lt;h3&gt;Backbone.js中View的陷阱&lt;/h3&gt;

&lt;p&gt;这里用陷阱这个词，是因为下面这些其实并不是Backbone.js本身所引发的问题，但却是使用Backbone.js的View时，常常会犯的错误。&lt;/p&gt;

&lt;h4&gt;绑定的事件没有解绑而造成的内存泄露&lt;/h4&gt;

&lt;p&gt;对于某个View，如果在它内部绑定事件的方式不正确，会造成&lt;code&gt;remove&lt;/code&gt;的时候没有解绑，最后造成内存泄露。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var SomeModelView = Backbone.View.extend({
    initialize: function() {
        this.model.on(&amp;#39;change&amp;#39;, this.render, this);
    },
    render: function() {
        // render a template
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有两种方式可以解决这个问题，第一个是使用&lt;code&gt;listenTo&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var SomeModelView = Backbone.View.extend({
    initialize: function() {
        this.listenTo(this.model, &amp;#39;change&amp;#39;, this.render);
    },
    render: function() {
        // render a template
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个是显式的在&lt;code&gt;close&lt;/code&gt;方法中解绑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var SomeModelView = Backbone.View.extend({
    initialize: function() {
        this.model.on(&amp;#39;change&amp;#39;, this.render, this);
    },
    close: function() {
        this.model.off(&amp;#39;change&amp;#39;, this.render);
    },
    render: function() {
        // render a template
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;如果没有特殊情况，都推荐使用第一种解决方案。&lt;/p&gt;

&lt;p&gt;其实以上的问题还不是真正的麻烦，真正的麻烦在于所有的View都需要以调用&lt;code&gt;remove&lt;/code&gt;的方式来删除，否则不仅是model或collection上面的事件无法解绑，DOM事件都会没有解绑，从而造成事件重复绑定或内存泄露的问题。而对于一个Backbone.js的应用来说，一个View有十多个内嵌了N层的SubView是很正常的情况，如何保证这些SubView都被remove掉了是非常大的问题，例如在切换页面的时候，需要首先删除一个页面级别的View再插入另一个。&lt;a href="http://mikeygee.com/blog/backbone.html"&gt;这里&lt;/a&gt;有一篇文章详细叙述了如何解决这个问题，我这里就不复述了。&lt;/p&gt;

&lt;h4&gt;DOM的render可能效率很低&lt;/h4&gt;

&lt;p&gt;如果多次使用append来插入SubView，由于每次都会导致浏览器重新计算Element的位置和大小，所以可能效率会很低，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var SomeCollectionView = Backbone.View.extend({
    initialize: function() {
        var self = this;
        this._views = [];
        // create a sub view for every model in the collection
        this.collection.each(function(model) {
            self._views.push(new SomeModelView({
                model: model
            }));
        });
    },
    render: function() {
        var self = this;
        this.$el.empty();
        // render each subview, appending to our root element
        _.each(this._views, function(subview) {
            self.$el.append(subview.render().el);
        });
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候我们可以使用&lt;code&gt;documentFragment&lt;/code&gt;来在内存中先把我们要插入的DOM组织好，再一次性的完成append操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;render: function() {
    this.$el.empty();
    var container = document.createDocumentFragment();
    // render each subview, appending to our root element
    _.each(this._views, function(subview) {
        container.appendChild(subview.render().el)
    });
    this.$el.append(container);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来这也不是真正麻烦的问题，至少我们还有解决方案，但是如果是一个大量数据的collection需要render，那么就需要我们自己在render的时候做增量式的操作，否则效率无论如何都提高不起来，这往往在老的浏览器或者移动端是无法接受的。&lt;/p&gt;

&lt;h3&gt;React.js的优点&lt;/h3&gt;

&lt;p&gt;如果我们有一个跟Backbone.js同样轻量级，并且又自己解决了以上问题的框架，我们为什么不试试看呢？&lt;/p&gt;

&lt;h4&gt;Virtual DOM&lt;/h4&gt;

&lt;p&gt;是的，所有的问题都可以使用一个Virtual DOM来解决。这个Virtual DOM由React.js来维护，每次对于DOM的修改都是增量式的，效率会非常高。并且对于删除的DOM，它上面的DOM事件会自动删除，不需要我们显式的调用一次，并且对于DOM的删除操作不需要显示的调用&lt;code&gt;remove&lt;/code&gt;，一切有React.js来搞定。&lt;/p&gt;

&lt;p&gt;这样就避免了很多内存泄露的可能性，也大大提高了性能。也就是同时解决了之前的两个问题。&lt;/p&gt;

&lt;h4&gt;Template与View不再分离&lt;/h4&gt;

&lt;p&gt;在大多数人的观念中，Template和View是完全不同的两种事物：一个是显示的内容，一个是显示的逻辑；一个是HTML，一个是JS。但是我们在实际开发的过程中，往往是开了两个窗口，左边是Template，右边是View，我们会非常欢快的在两边频繁切换。我们会做这样的操作，就是因为View的逻辑，就是Template的逻辑；Template的内容，其实也是View的内容。这两者没有大家想想的那么大的区别，分开以后反而是导致了代码不易读的问题，我常常会为了了解Template中的一个显示是如何得到的，而在各种View中找半天。&lt;/p&gt;

&lt;p&gt;Template与View的合并带来了代码可读性的提高，但是可能也有人会觉得把这两种合并到一起会让代码变得更加臃肿。这里就要提到React.js的Component这个概念了，有了Component的细化，其实每一个Component的代码是很独立，并且也很少的。&lt;/p&gt;

&lt;h4&gt;Component&lt;/h4&gt;

&lt;p&gt;Compnent这个概念的出现，就是为了使得页面组件可以更加容易的被重用。在React.js给出的官方&lt;a href="http://facebook.github.io/react/docs/thinking-in-react.html"&gt;示例中&lt;/a&gt;，我们可以看到Component的粒度可以非常细，同时可以利用&lt;a href="http://facebook.github.io/react/docs/transferring-props.html"&gt;Props&lt;/a&gt;来保证Component之间的解耦。&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;有了Virtual DOM，JSX（合并Template与View），Component这三大利器，React.js现在已经成为了Template和View这一层的不二框架了。再加上它本身的轻量级，还有Facebook来维护，采用它的风险可以说非常低。由于以上种种原因，是的一个两年不到的项目，在Github上有了13,120的Star数量，社区也提供了相当的热情&lt;/p&gt;

&lt;h3&gt;一些资料&lt;/h3&gt;

&lt;p&gt;下面是一些关于React.js的资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=-DX3vJiqxm4"&gt;Pete Hunt - The Secrets of React&amp;#39;s Virtual DOM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/21109361/why-is-reacts-concept-of-virtual-dom-said-to-be-more-performant-than-dirty-mode"&gt;Why is React&amp;#39;s concept of Virtual DOM said to be more performant than dirty model checking?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://calendar.perfplanet.com/2013/diff/"&gt;React’s diff algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>编写易读、可测试、可运行的API文档</title>
    <link rel="alternate" href="/2014/12/09/readable_testable_runnable_API_documentation.html"/>
    <id>/2014/12/09/readable_testable_runnable_API_documentation.html</id>
    <published>2014-12-09T03:31:00Z</published>
    <updated>2014-12-09T03:31:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img title="Document" alt="Document" src="/images/document.jpg?1418545547" /&gt;&lt;/p&gt;

&lt;p&gt;自从开放的API接口在社交媒体以及Web 2.0中运用的越来越广泛，API已经成为了互联网产品的标准配置。并且不光是对外提供API，对于前后端分离的应用，API也是非常重要的一部分。编写一个好的API，不光是代码写得好，最重要的是文档写得好。但是我们在写文档的时候尝尝会遇到下面几个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有统一的编写规范，这样不同的人在维护的时候尝尝会导致文档越来越乱，最终无法继续维护，也无法阅读。&lt;/li&gt;
&lt;li&gt;API修改以后，文档没有跟着改，或者改错了，导致API的使用者无法正常调用。&lt;/li&gt;
&lt;li&gt;作为前端开发，往往是在API开发完成以前，就要根据API的文档准备一些mock data来帮助开发，如果API文档可以直接生成一个mock server，就会非常方便&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们来看看如何构建能够解决以上问题的，完美的文档。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;&lt;img title="Document" alt="Document" src="/images/document.jpg?1418545547" /&gt;&lt;/p&gt;

&lt;p&gt;自从开放的API接口在社交媒体以及Web 2.0中运用的越来越广泛，API已经成为了互联网产品的标准配置。并且不光是对外提供API，对于前后端分离的应用，API也是非常重要的一部分。编写一个好的API，不光是代码写得好，最重要的是文档写得好。但是我们在写文档的时候尝尝会遇到下面几个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有统一的编写规范，这样不同的人在维护的时候尝尝会导致文档越来越乱，最终无法继续维护，也无法阅读。&lt;/li&gt;
&lt;li&gt;API修改以后，文档没有跟着改，或者改错了，导致API的使用者无法正常调用。&lt;/li&gt;
&lt;li&gt;作为前端开发，往往是在API开发完成以前，就要根据API的文档准备一些mock data来帮助开发，如果API文档可以直接生成一个mock server，就会非常方便&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们来看看如何构建能够解决以上问题的，完美的文档。&lt;/p&gt;

&lt;h3&gt;API Blueprint&lt;/h3&gt;

&lt;p&gt;所谓没有规矩，不成方圆。现在我要介绍的，就是一个API文档的规范：&lt;a href="https://apiblueprint.org/"&gt;API Blueprint&lt;/a&gt;。这个文档规范有以下的特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基于&lt;a href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt;，所以比较容易上手，同时机器和人都容易理解。&lt;/li&gt;
&lt;li&gt;由于是纯文本，所以可以进行版本管理。&lt;/li&gt;
&lt;li&gt;有非常多的相关工具，可以转为HTML，可以测试，可以作为Mock Server运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里是API Blueprint的&lt;a href="https://github.com/apiaryio/api-blueprint/blob/master/API%20Blueprint%20Specification.md"&gt;格式文档&lt;/a&gt;，如果觉得字太多了不好理解，这里还有一个&lt;a href="https://github.com/apiaryio/api-blueprint/blob/master/Tutorial.md"&gt;简化的教程&lt;/a&gt;。下面是一个简单的实例，包含了基本的元素及其说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 这里是API的名字
这里是API的描述

## 这里是Resource的名字 [/uri/to/resouce]
这里是Resource的描述

### 这里是Action的名字，后面跟Type [GET]
这里是Action的描述，下面就是Request与Response的示例了

+ Response 200

    + Headers

        Content-Type: application/json

    + Body

        {
            &amp;quot;id&amp;quot;: 1
            &amp;quot;name&amp;quot;: &amp;quot;some name&amp;quot;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们有了一份基本的API文档了，下面我们来介绍如何让这份文档更加可读，并且可以测试和运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;下面我会使用一个更加真实的&lt;a href="https://github.com/danielgtaylor/aglio/blob/master/example.md"&gt;API文档示例&lt;/a&gt;，并且之后所有的代码都可以在&lt;a href="https://github.com/zation/API-blueprint-demo"&gt;这里&lt;/a&gt;下载。&lt;/p&gt;

&lt;h3&gt;转化为更加易读的HTML页面&lt;/h3&gt;

&lt;p&gt;API Blueprint现在有两个开源工具可以生成静态HTML：&lt;a href="https://github.com/danielgtaylor/aglio"&gt;aglio&lt;/a&gt;和&lt;a href="https://github.com/subosito/iglo"&gt;iglo&lt;/a&gt;，这里使用aglio作为示例。并且为了我们可以实时的看到修改以后生成的HTML，我们同时引入了gulp作为实时的构建工具。&lt;/p&gt;

&lt;p&gt;首先，我们定义一个task，命名为document，用来生成HTML，以及实时刷新页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;#39;use strict&amp;#39;;

var gulp = require(&amp;#39;gulp&amp;#39;);
var aglio = require(&amp;#39;gulp-aglio&amp;#39;);
var connect = require(&amp;#39;gulp-connect&amp;#39;);
var watch = require(&amp;#39;gulp-watch&amp;#39;);

gulp.task(&amp;#39;document&amp;#39;, function() {
  return gulp.src([&amp;#39;documents/API.md&amp;#39;])
    .pipe(watch(&amp;#39;documents/API.md&amp;#39;))
    .pipe(aglio({template: &amp;#39;default&amp;#39;, filename: &amp;#39;./.tmp/index.html&amp;#39;}))
    .pipe(gulp.dest(&amp;#39;./.tmp/&amp;#39;))
    .pipe(connect.reload());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，我们创建一个task来启动静态页面服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gulp.task(&amp;#39;server&amp;#39;, function() {
  return connect.server({
    root: [&amp;#39;./.tmp&amp;#39;],
    port: 3456,
    livereload: {
      port: 35728
    }
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，为了方便，我们加上一个自动打开该静态页面的task：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gopen = require(&amp;#39;gulp-open&amp;#39;);

gulp.task(&amp;#39;open&amp;#39;, function() {
  return gulp.src(&amp;#39;./gulpfile.js&amp;#39;)
    .pipe(gopen(&amp;#39;&amp;#39;, {
      url: &amp;#39;http://localhost:3456&amp;#39;
    }));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，把上面的task加到默认的gulp task中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;server&amp;#39;, &amp;#39;document&amp;#39;, &amp;#39;open&amp;#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，可以运行&lt;code&gt;gulp&lt;/code&gt;来自动生成HTML的task了，并且浏览器会自动打开该页面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于aglio请求了很多外部静态资源，特别是google font，所以可能页面会打不开，我们可以写自己的template修正这个问题。&lt;/li&gt;
&lt;li&gt;由于aglio的一些依赖的需求，它只能运行在Node 11.10之前，建议使用Node 10.*。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;模块化的管理API文档&lt;/h3&gt;

&lt;p&gt;我们看到现在的API.md文件有283行，这还是只包含了三个group的。如果API的数量更多，那么全都写在一个markdown文件中会非常难以维护。这个时候我们就需要把一个markdown文件，拆分成多个，并且gulp脚本也需要一定的处理。&lt;/p&gt;

&lt;p&gt;首先，我们将API.md按照group，拆分为notes.md、users.md、tags.md。然后，我们需要在脚本中将这几个文件生成为一个，所以我们需要修改document task：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&amp;#39;gulp&amp;#39;);
var aglio = require(&amp;#39;gulp-aglio&amp;#39;);
var connect = require(&amp;#39;gulp-connect&amp;#39;);
var continuousConcat = require(&amp;#39;gulp-continuous-concat&amp;#39;);
var watch = require(&amp;#39;gulp-watch&amp;#39;);

gulp.task(&amp;#39;document&amp;#39;, function() {
  return gulp.src([&amp;#39;documents/API.md&amp;#39;, &amp;#39;documents/*.md&amp;#39;])
    .pipe(watch(&amp;#39;documents/*.md&amp;#39;))
    .pipe(continuousConcat(&amp;#39;API.md&amp;#39;))
    .pipe(aglio({template: &amp;#39;default&amp;#39;, filename: &amp;#39;./.tmp/index.html&amp;#39;}))
    .pipe(gulp.dest(&amp;#39;./.tmp/&amp;#39;))
    .pipe(connect.reload());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;这里使用&lt;code&gt;gulp-continuous-concat&lt;/code&gt;而没有使用&lt;code&gt;gulp-concat&lt;/code&gt;，是因为后者只在stream结束的时候才真的进行concat，这样就没有办法跟&lt;code&gt;gulp-watch&lt;/code&gt;一起用了，因为&lt;code&gt;gulp-watch&lt;/code&gt;是会让stream永久运行的。而&lt;code&gt;gulp-continuous-concat&lt;/code&gt;就没有这个限制。&lt;/p&gt;

&lt;h3&gt;将API文档作为Mock Server&lt;/h3&gt;

&lt;p&gt;作为一个前端开发，可能一个最头痛的问题就是与API的集成了。在实际开发的过程中，前后端会按照相互之间商量好的API分别开发，最后再集成到一起。但是后台API是尝尝会改动的，所以我们会遇到两个问题：后台改动后没有通知前端；后台修改并且通知后，前端没有修改mock的数据。这两种情况的结果都是集成失败，并且有可能前端需要一定的返工。&lt;/p&gt;

&lt;p&gt;那么怎么样才可以避免这个问题呢？只要我们保证文档就是Mock Server的数据来源，那么后台对于文档的任何修改，前端在开发过程中肯定会立刻知晓，并且也会反应在Mock Data上面。这也是我选用Api Blueprint的一大原因。下面我们来看看如何将API文档作为Mock Server启动起来。&lt;/p&gt;

&lt;p&gt;实际上非常简单，只需要安装&lt;code&gt;api-mock&lt;/code&gt;，然后运行&lt;code&gt;api-mock xxx.md&lt;/code&gt;就可以了。但是由于我们之前将文档拆分了，那么在启动之前需要我们先build一份完整的文档出来，所以我们需要在gulp脚本中加入下面这个task：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var connect = require(&amp;#39;gulp-connect&amp;#39;);

gulp.task(&amp;#39;build&amp;#39;, function() {
  return gulp.src([&amp;#39;documents/API.md&amp;#39;, &amp;#39;documents/*.md&amp;#39;])
    .pipe(concat(&amp;#39;API.md&amp;#39;))
    .pipe(gulp.dest(&amp;#39;./.tmp/&amp;#39;));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后为了方便运行，可以修改&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scrips&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;scripts&amp;quot;: {
  &amp;quot;start&amp;quot;: &amp;quot;gulp build &amp;amp;&amp;amp; api-mock ./.tmp/API.md --port 3457&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行&lt;code&gt;npm start&lt;/code&gt;就可以启动Mock Server了，你可以访问&lt;a href="http://localhost:3457/notes/1"&gt;http://localhost:3457/notes/1&lt;/a&gt;来测试一下。&lt;/p&gt;

&lt;h3&gt;测试你的文档&lt;/h3&gt;

&lt;p&gt;最后，我们还剩下唯一一个问题，就是如何保证我们的API文档与真实的API是一致的？自动化测试是一个有效的保证，&lt;a href="https://github.com/apiaryio/dredd"&gt;Dredd&lt;/a&gt;就是这样一个基于API Blueprint提供自动化测试的工具。&lt;/p&gt;

&lt;p&gt;Dredd的使用也很方便，只需要运行&lt;code&gt;dredd xxx.md http://url/to/api-server&lt;/code&gt;就可以了。为了方便，我们可以把测试脚本放在&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scripts&lt;/code&gt;中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;scripts&amp;quot;: {
  &amp;quot;test&amp;quot;: &amp;quot;gulp build &amp;amp;&amp;amp; dredd ./.tmp/API.md http://localhost:3458&amp;quot;,
  &amp;quot;start&amp;quot;: &amp;quot;gulp build &amp;amp;&amp;amp; api-mock ./.tmp/API.md --port 3457&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时我用express创建了一个简单的后台，使用&lt;code&gt;node server.js&lt;/code&gt;就可以启动，然后就可以运行&lt;code&gt;npm test&lt;/code&gt;查看文档测试的结果了。&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;虽然我们有了一个非常完美的文档系统，但是文档的本质作用是用于沟通，如果团队内部相互沟通的意愿不强烈，那么再好的工具没有办法用好，也不可能使用某个工具就可以建立起沟通的意愿。所以在团队建设的过程中，沟通、优化、负责等等好的意愿的建立是首位的，然后才是寻找到适合团队的工具来帮助解决问题，更好的发挥意愿。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>国内项目天坑记（二）——Gruntfile的模块化</title>
    <link rel="alternate" href="/2014/06/09/grunt_config_as_modules.html"/>
    <id>/2014/06/09/grunt_config_as_modules.html</id>
    <published>2014-06-09T15:31:00Z</published>
    <updated>2014-06-09T15:31:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;在大型项目中用过Grunt的都知道，当自动化的配置和task多了一个，一个Gruntfile.js文件可能有好几百行，这样维护非常困难，于是对Gruntfile的模块化势在必行。感谢&lt;a href="http://zhuanlan.zhihu.com/tla42"&gt;墨磊&lt;/a&gt;同学帮助我们做了模块化！以下内容都是他的实践。&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;在大型项目中用过Grunt的都知道，当自动化的配置和task多了一个，一个Gruntfile.js文件可能有好几百行，这样维护非常困难，于是对Gruntfile的模块化势在必行。感谢&lt;a href="http://zhuanlan.zhihu.com/tla42"&gt;墨磊&lt;/a&gt;同学帮助我们做了模块化！以下内容都是他的实践。&lt;/p&gt;

&lt;p&gt;本质上Gruntfile.js就是一个node.js代码文件，所以我们可以很方便的用&lt;a href="http://www.commonjs.org"&gt;CommonJS&lt;/a&gt;的规范将Gruntfile.js模块化。下面我们首先来看看模块化以后的grunt目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Gruntfile.js
grunt/
    compile/
        compass.js
        concat.js
        uglify.js
        ...
    dev/
        jshint.js
        connect.js
        ...
    config.js
    tasks.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里要提一下grunt模块划分，一般是根据task的不同来划分的。而&lt;a href="http://gulpjs.com/"&gt;gulp&lt;/a&gt;是根据处理的文件类型的不同来划分的。&lt;/p&gt;

&lt;p&gt;Gruntfile.js所做的事情就很简单了，只是加载tasks.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;#39;use strict&amp;#39;;

module.exports = function (grunt) {
    // load tasks
    require(&amp;#39;./grunt/tasks.js&amp;#39;)(grunt);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tasks.js负责加载和注册所有的tasks和config.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function (grunt) {

    require(&amp;#39;./config.js&amp;#39;)(grunt);

    grunt.loadTasks(&amp;#39;./grunt/compile&amp;#39;);
    grunt.loadTasks(&amp;#39;./grunt/dev&amp;#39;);

    grunt.registerTask(&amp;#39;some tasks&amp;#39;, function () {
        //...
    });

    return grunt;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这里&lt;code&gt;grunt.loadTasks()&lt;/code&gt;方法的路径是相对于Gruntfile.js的。&lt;/p&gt;

&lt;p&gt;config.js负责配置项目相关的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function (grunt) {
    grunt.initConfig({
        // configurable paths
        server: {
            hostname: &amp;#39;0.0.0.0&amp;#39;,
            hostport: &amp;#39;9000&amp;#39;
        },
        testServer: {
            hostname: &amp;#39;localhost&amp;#39;,
            hostport: &amp;#39;9001&amp;#39;
        },
        yeoman: {
            app: &amp;#39;app&amp;#39;,
            dist: &amp;#39;dist&amp;#39;,
            test: &amp;#39;test&amp;#39;,
            tmp: &amp;#39;.tmp&amp;#39;
        }
    });

    return grunt;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;compile文件夹下的tasks是在build production package的时候用到的，dev文件夹下的tasks是在开发环境中用到的，这里也可以根据项目的实际情况进行分类。&lt;/p&gt;

&lt;p&gt;这里我认为还可以做优化的地方在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用.json配置文件代替.js配置文件，并且预先设订好对于不同环境的配置文件，例如：config.json.development, config.json.production, config.json.staging, config.json.test&amp;hellip; 不同的环境中就使用不同的配置文件，这样让所有的配置文件都可以做版本管理，而且也更加统一。&lt;/li&gt;
&lt;li&gt;使用npm将这些配置代码都打包，放到另一个独立的github repo中，这样可以简化项目结构和代码，同时也利于这些代码在其他项目中的共用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些优化我已经在新的项目中进行过尝试了，效果挺不错的，后面会写一篇更加详细的文章来进行介绍。&lt;/p&gt;
</content>
  </entry>
</feed>
